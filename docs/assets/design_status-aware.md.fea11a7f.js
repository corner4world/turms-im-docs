import{_ as e,o as t,c as s,U as a}from"./chunks/framework.95a60cb2.js";const g=JSON.parse('{"title":"Status Awareness","description":"","frontmatter":{},"headers":[],"relativePath":"design/status-aware.md","filePath":"design/status-aware.md"}'),o={name:"design/status-aware.md"},i=a(`<h1 id="status-awareness" tabindex="-1">Status Awareness <a class="header-anchor" href="#status-awareness" aria-label="Permalink to &quot;Status Awareness&quot;">​</a></h1><p>Status awareness is divided into two categories, one is &quot;user online status awareness&quot;, and the other is &quot;business data change awareness&quot; (such as receiving new messages, group members sending changes).</p><p>Since the specific implementation of state awareness is closely related to specific product requirements, you need to be able to grasp the following two points:</p><ol><li>Determine whether the product demand is reasonable. Usually unreasonable requirements, such as: there can be 10,000 users in a group, when a user sends a message, it is necessary to ensure that the message can be 100% sent to other 9999 users, and the user can pull a few years ago Chat information.</li><li>Distinguish primary and secondary requirements, and try to strike a balance between quality attributes. There are many details in the implementation of IM services. Is it really necessary to design a large number of back-and-forth strategies (such as message session-level auto-increment IDs) in order to be compatible with extreme situations, which not only greatly increases the development cost and failure points, but also makes the overall server throughput drops.</li></ol><h2 id="user-online-status-awareness" tabindex="-1">User online status awareness <a class="header-anchor" href="#user-online-status-awareness" aria-label="Permalink to &quot;User online status awareness&quot;">​</a></h2><p>In short, Turms detects the health status of the user&#39;s TCP connection through the heartbeat packet and judges whether the user is &quot;online&quot;. Also, if you don&#39;t care about the underlying implementation, you only need to read: <a href="https://turms-im.github.io/docs/client/api#%E4%BC%9A%E8%AF%9D%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" target="_blank" rel="noreferrer">Client API - Session Lifecycle</a>.</p><h3 id="specific-principles-expanding-knowledge" tabindex="-1">Specific principles (expanding knowledge) <a class="header-anchor" href="#specific-principles-expanding-knowledge" aria-label="Permalink to &quot;Specific principles (expanding knowledge)&quot;">​</a></h3><h4 id="background" tabindex="-1">background <a class="header-anchor" href="#background" aria-label="Permalink to &quot;background&quot;">​</a></h4><p>From the perspective of the network transport layer, TCP is just a virtual connection, which needs to simulate a physical connection through two-way message delivery and message confirmation. In the case of waving for the first time (that is, the specified message transmission and confirmation is not completed), TCP still determines that the connection is in a hold state (if you try to read data from the TCP connection at this time, it will throw a message similar to &quot;An existing connection was forcibly closed by the remote host&quot; message). Therefore, for the upper-layer instant messaging application developed based on the TCP protocol, if we do not do extra work, the server can only mistakenly believe that &quot;the user is online&quot;.</p><h4 id="common-reasons-why-tcp-did-not-complete-the-four-wave" tabindex="-1">Common reasons why TCP did not complete the four wave <a class="header-anchor" href="#common-reasons-why-tcp-did-not-complete-the-four-wave" aria-label="Permalink to &quot;Common reasons why TCP did not complete the four wave&quot;">​</a></h4><ul><li>Client: The client application is forcibly closed</li><li>Server: The load continues to be too high to respond; the server directly goes down, causing the server application to be forcibly closed</li><li>Link intermediate routing: unexpected interruption (eg: mobile access network NAT timeout)</li></ul><h4 id="solutions-for-abnormal-disconnection" tabindex="-1">Solutions for abnormal disconnection <a class="header-anchor" href="#solutions-for-abnormal-disconnection" aria-label="Permalink to &quot;Solutions for abnormal disconnection&quot;">​</a></h4><p>In order to ensure that the server can perceive the state of &quot;user offline&quot;, the Turms client will, after a certain time interval from the last request of any type (such as a request to send a message) (for now, it does not support the configuration of smart heartbeat according to network conditions), Send heartbeat packets to the server to maintain its &quot;online status&quot;. After the server receives the heartbeat packet or other business requests from the client, it will refresh the online status of the client on the Redis server to keep alive.</p><h2 id="business-data-change-perception" tabindex="-1">Business data change perception <a class="header-anchor" href="#business-data-change-perception" aria-label="Permalink to &quot;Business data change perception&quot;">​</a></h2><p>In order to allow users to perceive changes in business data (addition, deletion, modification), Turms supports push mode (server-side active notification), pull mode (client-side active pull mechanism. Support pull by Timeline) and push-pull combination mode to achieve real-time Balance between real-time performance and resource consumption, and allow developers to adjust the weight between real-time performance and resource consumption.</p><h3 id="perception" tabindex="-1">Perception <a class="header-anchor" href="#perception" aria-label="Permalink to &quot;Perception&quot;">​</a></h3><h4 id="method-1-push-mode-active-notification-from-the-server" tabindex="-1">Method 1: push mode (active notification from the server) <a class="header-anchor" href="#method-1-push-mode-active-notification-from-the-server" aria-label="Permalink to &quot;Method 1: push mode (active notification from the server)&quot;">​</a></h4><p>The push mode means that when a certain business model changes (due to addition, deletion and modification operations), the server will actively notify the relevant online users of the occurrence of the event. When the client receives the notification, the Turms client will trigger the <code>onNotification</code> callback function in <code>NotificationService</code>. The parameter of this function is a <code>TurmsRequest</code> object, indicating the request that triggered the event.</p><p>Notification-related behaviors can be configured according to the <code>im.turms.server.common.infra.property.env.service.business.NotificationProperties</code> class. Each notification type can be configured individually, and all notification-related configurations can be dynamically updated while the cluster is running.</p><h5 id="example" tabindex="-1">Example <a class="header-anchor" href="#example" aria-label="Permalink to &quot;Example&quot;">​</a></h5><p>Take the property <code>im.turms.server.common.infra.property.env.service.business.NotificationProperties#notifyMembersAfterGroupUpdated</code> as an example. This attribute is used to control &quot;whether to notify group members when group information changes&quot;. The group information here refers to global group information such as group name, group type, and group silence time.</p><p>If you set this attribute value to true, when the group information changes, the clients of the group members will receive a notification that triggers the change. Otherwise, group member clients will not receive any notifications.</p><h5 id="evaluate" tabindex="-1">evaluate <a class="header-anchor" href="#evaluate" aria-label="Permalink to &quot;evaluate&quot;">​</a></h5><p>The notification mechanism can ensure that notifications can be delivered to relevant users in real time, but its disadvantage is that it can easily lead to meaningless resource consumption (subject to specific business scenarios). For example, user A has joined 100 groups, but the user usually only checks the information of 3 of them. In this scenario, if the notification mechanism is enabled for all status changes of 100 groups, both the server and the client need to waste a lot of resources to deal with these meaningless notifications (because the user never reads these notifications) .</p><p>In order to solve this type of problem and meet other common needs (such as: requiring offline users to detect whether the business model has changed when they go online; requiring online users to perceive changes in the business model even when the notification is turned off) , Turms also provides a pull mode (the client actively pulls) to allow users to perceive changes in the business model.</p><h4 id="method-2-pull-mode-the-client-actively-pulls-supports-pulling-by-timeline" tabindex="-1">Method 2: Pull mode (the client actively pulls. Supports pulling by Timeline) <a class="header-anchor" href="#method-2-pull-mode-the-client-actively-pulls-supports-pulling-by-timeline" aria-label="Permalink to &quot;Method 2: Pull mode (the client actively pulls. Supports pulling by Timeline)&quot;">​</a></h4><p>In order to make up for the deficiencies of the push mode mentioned above, Turms also provides a pull mode.</p><h5 id="about-to-achieve" tabindex="-1">About to achieve <a class="header-anchor" href="#about-to-achieve" aria-label="Permalink to &quot;About to achieve&quot;">​</a></h5><p>Each business model of Turms has a version information, which records the time when the business model was last updated. When the client requests resources from the server, it can carry the time when the client last updated the business model (or not). The Turms server will compare this version information with the version information of the current business model. If the client If the version information sent by the client is earlier than the version information of the current business model, the Turms server will return the latest business model data, otherwise the status code <code>NO_CONTENT</code> will be thrown, and the client will receive empty data.</p><h5 id="common-pull-timing-synchronization-timing" tabindex="-1">Common pull timing (synchronization timing) <a class="header-anchor" href="#common-pull-timing-synchronization-timing" aria-label="Permalink to &quot;Common pull timing (synchronization timing)&quot;">​</a></h5><ul><li>When your app is switched to the foreground</li><li>When the session is reconnected</li><li>Depends on specific business (see example below)</li></ul><h5 id="example-1" tabindex="-1">Example <a class="header-anchor" href="#example-1" aria-label="Permalink to &quot;Example&quot;">​</a></h5><p>Continuing with the example above. Assume that we want group members to be able to perceive changes in the profile information of other group members in real time. Then if we adopt the notification mechanism, assuming that each group has 100 other online users besides user A, then user A’s profile information needs to be notified to other 10,000 (100 groups*100 people/group) group members, This is absolutely undesirable in practical applications.</p><p>In practice, usually at a specific time (for example, when the user opens a user&#39;s personal information UI interface, or opens a chat window with someone), the client will actively request the server for the user&#39;s information. At the same time, use version comparison to reduce meaningless waste of resources.</p><p>This kind of design that always pays attention to real-time and resource consumption should be kept in mind, so as not to design unrealistic application scenarios.</p><h3 id="the-real-time-perception-of-user-behavior-by-the-client-and-the-delay-of-the-server" tabindex="-1">The real-time perception of user behavior by the client and the delay of the server <a class="header-anchor" href="#the-real-time-perception-of-user-behavior-by-the-client-and-the-delay-of-the-server" aria-label="Permalink to &quot;The real-time perception of user behavior by the client and the delay of the server&quot;">​</a></h3><p>Taking the related implementation of blocking users as an example, Turms caches user relationships for 1 minute by default to avoid frequent database queries, which is a reasonable behavior. If user A &quot;blocks&quot; user B at this time, it may appear that although user A has blocked user B, user B may still be able to send messages to user A during the cached period (because The Turms server is a distributed cluster, and the relational cache and the server that receives the blacklist request are not necessarily the same server). <strong>This behavior is acceptable to the Turms server, not a bug</strong>.</p><p>Its reasonable and ideal reference solution is: on the business level of the client (the business logic is controlled by you, not by the Turms client), even if the Turms server sends a message to the Turms client, your client should also follow the The business logic of your product itself, judge whether the user has been blocked again, and if so, hide it or not.</p><h2 id="message-awareness" tabindex="-1">Message awareness <a class="header-anchor" href="#message-awareness" aria-label="Permalink to &quot;Message awareness&quot;">​</a></h2><h3 id="read-flooding-and-write-flooding" tabindex="-1">Read flooding and write flooding <a class="header-anchor" href="#read-flooding-and-write-flooding" aria-label="Permalink to &quot;Read flooding and write flooding&quot;">​</a></h3><p>The architecture of Turms is designed based on the read diffusion message model. The following table compares the advantages and disadvantages of read flooding and write flooding for readers&#39; reference:</p><table><thead><tr><th></th><th>Read Diffusion</th><th>Write Diffusion</th></tr></thead><tbody><tr><td>Meaning</td><td>1. Each user has an individual conversation (also known as mailbox or Timeline) with other users or groups that they chat with. <br>2. When a user sends a message, regardless of private chat or group chat, the database only needs to store a message record. <br>3. When the user queries the message, the client needs to send a request to the server to pull the message of the specified session ID list; Chat session messages, and then use a request to specify the group chat session ID list to pull group chat messages</td><td>1. Each user has and only one mailbox. <br>2. When a user sends a message, the message needs to be written to the mailboxes of all members in the session, that is, if there are 100 other members in the group chat, the message needs to be written 100 times. <br>3. When the user queries the message, the client does not need to specify the session ID list, but only needs to send a request to the server to read the message in its own mailbox</td></tr><tr><td>Advantageous Scenarios</td><td>Scenarios where there are relatively few user sessions (private chat sessions and group chat sessions) and a large number of groups. <br>Note: If the application only has private chat sessions and no group chat sessions, then under the implementation of the Turms server, the advantages and disadvantages of read flooding and write flooding are not much different, because both message models only require When a user sends a message, the database writes a message; when a user reads a message, the database looks up the table once based on the index (Turms uses a composite index of <code>message sending time + recipient ID</code>, see <a href="https://turms-im.github.io/docs/design/schema#%E9%9B%86%E5%90%88%E8%AF%A6%E8%A7%A3" target="_blank" rel="noreferrer">Message Collection Design</a>)</td><td>To avoid too many Message copying, so write diffusion is relatively more suitable for scenarios where there are many group chats but few group members</td></tr><tr><td>Disadvantageous scenarios</td><td>Because the client needs to specify the ID list of group chat sessions, the disadvantageous scenario of read diffusion is: there are many group chat sessions, and users read messages frequently. <br>Reminder: The Turms server uses a MongoDB client request to complete the above query operations based on the index, so the performance is actually very efficient. Only compared to write flooding, this scenario is a disadvantageous scenario for read flooding</td><td>because the more group members, the more times the message is copied, so the disadvantageous scenario of write flooding is: a single group has many members, and the group members are frequent send message</td></tr><tr><td>Technical Implementation</td><td>1. Read requests can be load-balanced through MongoDB&#39;s shard copy architecture<br>2. All read requests are implemented based on indexes, with high performance</td><td>1. Write operations are difficult to load-balance<br> br /&gt;2. The cost of implementing IM functions such as updating messages and withdrawing messages is huge, and distributed consistency issues and message storms need to be considered</td></tr><tr><td>Message reliability</td><td>If the product has high requirements on message reliability, that is, to ensure that the message is not lost and that the content of the message is consistent, then the implementation of read diffusion is much simpler, because the database only needs to store one message, and the user only needs to Read this message</td><td>Because it is necessary to ensure that the message is written to the mailbox of each group member, it is necessary to introduce a weak distributed consistency transaction (or a strong distributed consistency transaction), otherwise the message may be lost, but the distributed consistency Transactions cause poor throughput</td></tr><tr><td>General Comments</td><td>1. Read diffusion is applicable to a wide range of products. For the characteristics of huge cost to implement write diffusion, based on the implementation of read diffusion, usually only the client needs to customize the query conditions and send a query statement to the Turms server. (such as group new member message sharing, multi-terminal message synchronization), the server does not need to change a line of code, and these query tasks are completed based on the index. <br>2. Read diffusion can still rely on indexes to ensure high efficiency in disadvantageous scenarios</td><td>Since write diffusion requires writing a large number of messages, any update operations (withdrawal/update) also need to use distributed transactions, and The implementation of IM features (such as group new member message sharing, multi-terminal synchronization) is very complicated. <br>In summary, the business expansion of writing diffusion is extremely poor, and its usage scenarios are basically limited to: applications are basically private chats, no group chats, and the business functions are simple, but for applications that only have private chats, as mentioned above , the performance of read flooding or write flooding is similar. <br>If your team&#39;s product manager asks to add business functionality, your development team will quickly realize how fatal the design of an IM system is to only support write flooding. Read diffusion can be a very efficient and easy-to-implement function, but for write diffusion, this becomes an inefficient and difficult-to-implement function</td></tr></tbody></table><p>Emphasize again: unless you are very clear that the use case of your product is as simple and limited as above (the number of private chat sessions does not matter, but the number of group chat sessions is large and the number of group members is small), and the future business needs will basically remain unchanged, otherwise use Understanding the write diffusion message model basically means that your product will one day need to refactor the readback diffusion model, or support both reading and writing models. Of course, write diffusion can also be retained for a long time as &quot;technical debt&quot;.</p><p>remind:</p><ul><li>Changing from a write-diffusion implementation to a read-diffusion implementation almost means recreating the design and implementation of the entire project from scratch. Also because the impact of the message model on the IM architecture is so great, when we talk about the Turms architecture, the first sentence is always &quot;Turms architecture is designed based on the read diffusion message model&quot;.</li><li>In the implementation of the Turms server, the &quot;withdrawal message&quot; is also a message, that is, a special system message.</li></ul><h3 id="message-reception-message-update-and-message-withdrawal" tabindex="-1">Message reception, message update and message withdrawal <a class="header-anchor" href="#message-reception-message-update-and-message-withdrawal" aria-label="Permalink to &quot;Message reception, message update and message withdrawal&quot;">​</a></h3><p>Turms implements message reception, update and withdrawal on the client side based on the above-mentioned &quot;push mode&quot; and &quot;pull mode&quot;. in:</p><ul><li><p>Combining the above &quot;common pull timing&quot; and the following &quot;About message accessibility, order and repeatability&quot;, Turms can achieve 100% message arrival, message consistency sorting and deduplication</p></li><li><p>The notification of message update and withdrawal is essentially a message, that is, a special system message. After receiving the message update or cancellation request from the user, the Turms server will first judge whether the function is enabled, whether the user has permission, whether it is within a certain time interval, etc. If the verification passes, it will (hereinafter referred to as the withdrawal message Take the process as an example, the update message is the same):</p><ul><li><p>The Turms server first modifies the target original message record stored in the database, and marks it with a timestamp of &quot;message withdrawn&quot;.</p></li><li><p>Then generate a &quot;withdrawal message&quot; system message (note that it is a <code>message</code>, not a notification <code>notification</code>), and insert it into the message collection.</p></li><li><p>Finally, send the above-mentioned &quot;withdrawal message&quot; system message to the corresponding online users to inform these clients that some messages have been withdrawn before.</p><p>After the client receives the system message, the developer needs to do the processing on the corresponding business layer (the Turms client will not do any other logical processing except for parsing which messages are withdrawn), such as physically deleting the message locally. message, or just hide it, or replace a retracted message with something like &quot;This message was retracted at XX time&quot;, etc.</p><p>Supplement: As mentioned above, when the current Turms server processes a withdrawal message, it will send a &quot;withdrawal message&quot; system message to the corresponding online client to ensure that the online client can quickly withdraw the locally received message. Configuration items will also be added to support applications that do not want the Turms server to actively send this system message.</p></li><li><p>If the user is already offline and has not received the &quot;withdrawal message&quot; system message, then when the user logs in next time, it still needs to actively pull the message received when offline, so in the process of pulling By the way, the &quot;withdrawal message&quot; system message inserted above will also be pulled down. When developers detect such system messages, they can do specific business layer processing.</p><p>Reminder: Developers can use the <code>addMessageListener</code> interface in the message service provided by the client side to determine whether the received message is a system message of &quot;withdrawal message&quot;. Take the turms-client-js client as an example:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">turmsClient</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;"> messageService</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">addMessageListener</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">message</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">addition</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">addition</span><span style="color:#89DDFF;">.</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">recalledMessageIds</span><span style="color:#89DDFF;">.</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">length</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">// is a system message to recall messages</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">        </span><span style="color:#676E95;font-style:italic;">//not</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div></li></ul></li></ul><p>in addition:</p><ul><li>Regarding the process of deleting messages on the Turms server, the Turms server currently only performs soft delete or hard delete on the messages, and does not perform any logic related to &quot;withdrawing messages&quot;. We will add corresponding configuration items to Turms in the future to support applications that want to withdraw messages when they want to delete messages.</li><li>At present, the Turms server does not provide complete support for &quot;update message&quot; like &quot;withdraw message&quot;, and the optimization of this part will be completed in the near future.</li></ul><h3 id="about-the-reachability-orderliness-and-repeatability-of-messages" tabindex="-1">About the reachability, orderliness and repeatability of messages <a class="header-anchor" href="#about-the-reachability-orderliness-and-repeatability-of-messages" aria-label="Permalink to &quot;About the reachability, orderliness and repeatability of messages&quot;">​</a></h3><p>Architectural design is always the art of balance, and blindly promising 100% news is just a sales rhetoric. For example, most Internet applications will only use weakly distributed transactions with better performance in the technical implementation of distributed transactions, rather than strong distributed transactions that are more reliable but have low performance. Whether it is necessary to achieve 100% message delivery depends on the business scenario. For example, in the live chat room scenario, not only does it not require that the message must arrive, but it even requires the server to actively discard user messages according to the load situation and message priority, or only send the message to some users.</p><p>The live broadcast scene may not require the order of messages, but requires &quot;how to design a message with a high throughput. Try to ensure the order of the messages, but do not provide additional auxiliary resources for support.&quot; Some designed IM applications can also &quot;in order to achieve a balance between high throughput and high reachability, use the non-message must reach mechanism for free groups, and use the message must reach mechanism for VIP groups&quot;. The needs of practical applications are always varied.</p><p>Therefore, it is emphasized again: when doing functional design, it is necessary to distinguish between primary and secondary requirements, and to strike a balance between quality attributes as much as possible. Never leave the business scene and work behind closed doors.</p><h4 id="summarize" tabindex="-1">Summarize <a class="header-anchor" href="#summarize" aria-label="Permalink to &quot;Summarize&quot;">​</a></h4><p>Since the specific implementation comparison of various message features below is relatively complicated, this summary section quickly summarizes the final solution for you.</p><p>In general, Turms is designed to follow the principle that the client can implement it itself, and the Turms server does not implement it, so as to achieve maximum throughput and flexible business implementation. If the feature must be implemented by the server and has little impact on throughput, it is enabled by default, otherwise it is disabled by default\`, specifically:</p><ul><li><p>Accessibility</p><ul><li><p>Solution 1: If you want to achieve almost 100% message delivery, you can enable <code>use-sequence-id-for-group-conversation</code> and <code>use-sequence</code> under <code>turms.service.message.sequence-id</code> -id-for-private-conversation<code>(default configuration, all closed), this mechanism will request a session-level auto-increment</code>sequence ID\` from Redis every time a message record is generated, and assign this ID to the current In the message record, the client can judge whether the message is lost through the auto-increment of the ID and the message sending time (the need to judge the message sending time is because: if Redis crashes and the serial number data is lost, the serial ID will be calculated from the beginning, and when If the client detects that the serial number has become smaller, it can then determine which message is the latest message based on the message sending time).</p><p>Note: <code>sequence ID</code> has nothing to do with <code>message ID</code>.</p></li><li><p>Option 2 (default implementation): If you do not require messages to be 100% guaranteed, turn off the above configuration to obtain greater message push throughput.</p></li></ul></li><li><p>Orderliness</p><ul><li><p>Sequential eventual consistency</p><ul><li>Option 1: Use the self-incrementing <code>sequence ID</code> mentioned above to realize the order of messages &quot;by the way&quot;</li><li>Solution 2: (default implementation) Use server time to ensure message order. Reminder: Not only messages need to use the system time, but also various functional modules of the Turms server heavily use the system time, such as the ID generated based on the Snowflake algorithm, the timestamp of the log, and the current limiting and anti-scraping mechanism based on the timestamp.</li></ul></li><li><p>Consistency in receiving order: Some IM systems will delay sending messages or displaying messages on the client side to avoid as much as possible &quot;the client first receives the message sent later, and then receives the message sent earlier&quot;, resulting in a message UI Need to rearrange. However, Turms has no plans to provide relevant support</p></li><li><p>Causal consistency: When the client sends a message, it can carry the <code>preMessageId</code> field, which is used to indicate what the last message ID displayed on the message sending client UI is. This record has no practical effect on Turms itself, but other clients can refer to this value for upper-level message UI display to achieve causal consistency of message logic between clients.</p><p>Note: <code>preMessageId</code> has nothing to do with the implementation of &quot;message reachability&quot;, it is only used for your product to sort the message UI</p></li></ul></li><li><p>Repeatability. In this regard, the Turms server only provides message records with unique global IDs. The deduplication of messages needs to be implemented by the developer on the client side: if your application needs to achieve 100% deduplication of messages, you need to consider the received The message ID. If your application only needs to ensure deduplication of messages within the life cycle of an application, you only need to store the received message ID in memory, and whenever the server pushes a new message, you only need to judge whether the message with this ID has been processed That&#39;s it.</p><p>Reminder: usually only need to store the message ID of the latest local time (such as the last 1 day), there is no need for full storage</p></li></ul><p>In addition, the following will explain a common but often very failed design scheme in the industry, that is, the scheme of &quot;message confirmation mechanism requiring server participation&quot; as a negative case. It achieves the worst &quot;reachability&quot; and &quot;repeatability&quot; effects at the highest cost, and its performance and scalability are also extremely poor. <strong>(TODO: This part of the documentation has not been updated)</strong></p><h3 id="message-confirmation-mechanism-acknowledge" tabindex="-1">Message Confirmation Mechanism (Acknowledge) <a class="header-anchor" href="#message-confirmation-mechanism-acknowledge" aria-label="Permalink to &quot;Message Confirmation Mechanism (Acknowledge)&quot;">​</a></h3><p>It is worth noting that:</p><ol><li>The message confirmation mechanism of Turms does not require the participation of the Turms server</li><li>The message confirmation mechanism is completely independent from the &quot;read message&quot; function at the business level, and there is no relationship between the two.</li></ol><table><thead><tr><th></th><th>Ack mechanism that requires server participation</th><th>Ack mechanism that does not require server participation</th></tr></thead><tbody><tr><td>Introduction</td><td>In some instant messaging architecture designs, the client is required to send a message confirmation request to the server at a certain interval (such as 5 seconds, 10 seconds, etc.) after receiving the message (instead of confirming as soon as the message is received. One is to improve the efficiency of confirmation processing, and the other is to reduce the probability of losing messages due to network delays). <br>The server records the latest confirmation time of each session, so that when the user pulls messages from all sessions (such as when the user goes online), he can pull all the messages from the confirmation time to the present through a simple request.</td><td>The client stores the last confirmation time of each session locally. If the client wants to obtain any session message to which it belongs, it sends the corresponding session ID and confirmation time to the server, and the server returns all messages from the confirmation time to the present.</td></tr><tr><td>Advantages</td><td>1. The client is simple to implement and does not need to store session information locally</td><td>1. The client can customize the range of message fetching. The business is more applicable and can easily support multi-terminal message synchronization<br>2. The server does not need to check the confirmation time of all sessions first, and then pull the message according to the Ack time, which has better performance<br>3. The client does not need to send confirmation requests to the server regularly, which can completely save the performance overhead caused by a large number of confirmation operations</td></tr><tr><td>Disadvantages</td><td>1. The server needs to check the confirmation time of all sessions first, and then pull the message according to the confirmation time. The performance is relatively poor<br>2. For each message received, the client needs to send a confirmation to the server 1. When the client sends a request, it needs to carry all the session IDs of the message to be requested and the corresponding confirmation time, and the request body is relatively large (but it also corresponds to the above ② Advantages)<br>2. Developers are required to implement the client&#39;s local database (such as: Realm database. Turms may help developers implement local storage functions in the future in an extended form)</td><td></td></tr></tbody></table><h3 id="about-message-reachability" tabindex="-1">About message reachability <a class="header-anchor" href="#about-message-reachability" aria-label="Permalink to &quot;About message reachability&quot;">​</a></h3><p>Architectural design is always the art of balance, and blindly promising 100% news is just a sales rhetoric. For example, most Internet applications will only use weakly distributed transactions with better performance in the technical implementation of distributed transactions, rather than strong distributed transactions that are more reliable but have low performance. Whether it is necessary to achieve 100% message delivery or not depends on the business scenario (for example, in the live chat room scenario, not only is the message not required to be delivered, but the server is even required to actively discard user messages according to the load situation).</p><p>The solution to achieve 100% delivery of messages is also relatively simple. A session-level self-incrementing ID generation server can be implemented through Redis to ensure that message IDs are incremented within a session. The client can judge whether there is a message missing through the incrementality of the ID. If it finds that the message is missing, it can send a request to the server to get the specified message.</p><p>Turms will also support the above-mentioned session-level message auto-increment ID implementation to ensure 100% message delivery (TODO), and also provide a global auto-increment ID implementation based on the Snowflake algorithm to provide the best throughput (the cost is that the message cannot guarantee 100% % must reach).</p><h3 id="about-the-realization-of-the-number-of-unread-messages" tabindex="-1">About the realization of the number of unread messages <a class="header-anchor" href="#about-the-realization-of-the-number-of-unread-messages" aria-label="Permalink to &quot;About the realization of the number of unread messages&quot;">​</a></h3><h4 id="business-needs" tabindex="-1">Business needs <a class="header-anchor" href="#business-needs" aria-label="Permalink to &quot;Business needs&quot;">​</a></h4><ul><li>When used as a desktop badge (Badge Number), display the total number of unread messages (iOS must calculate the total number on the server side). Need to support offline update, or do not need to support offline update</li><li>When used as a conversation badge in the app, it displays the number of unread messages for each conversation</li></ul><h4 id="plan" tabindex="-1">plan <a class="header-anchor" href="#plan" aria-label="Permalink to &quot;plan&quot;">​</a></h4><table><thead><tr><th></th><th>Does not support offline message push with unread message count (default implementation)</th><th>supports offline message push with unread message count (TODO)</th></tr></thead><tbody><tr><td>Implementation</td><td>When the client receives and pulls messages, it sends a request to the server to calculate the &quot;unread messages&quot; in real time. <br>In this solution, the Turms server does not actually have the concept of <code>unread message count</code>, the server only calculates the number of messages within a certain message sending time interval according to the client&#39;s request</td><td>Use Redis to support offline messages Carry the number of unread messages when pushing: carry the number of unread messages in the session and the total number of unread messages; only carry the total number of unread messages Add 1 to the number of unread messages, and add 1 to the total<br>When the user reads the message, or when the user or group is deleted, do the opposite subtraction operation in the Redis record<br>(**Note: The total number of unread messages must be calculated by the server **)</td></tr><tr><td>Advantages</td><td>1. The implementation is simple and can flexibly support various business needs, without the need to introduce a Redis server<br>2. When sending a message, there is no need to send a request to Redis to calculate the number of unread messages, and the write throughput is higher</td><td>1. Support offline message push to carry the number of unread messages<br>2. When reading unread messages, no real-time calculation is required, and the read throughput is higher</td></tr><tr><td>Disadvantages</td><td>1. Does not support the number of unread messages carried when offline messages are pushed<br>2. When the client reads the number of unread messages, real-time calculation is required, and the read throughput is lower (supplement: index support)</td><td>1 . Redis server needs to be introduced to increase the cost and difficulty of operation and maintenance<br>2. Every time the server receives a new message, Redis needs to send a request to calculate the number of unread messages, and the write throughput is lower</td></tr><tr><td>Relationship with unread messages</td><td><code>Unread messages</code> and <code>Number of unread messages</code> both take the terminal as the dimension, and the client sends the local message to the service through the above-mentioned client to confirm the last confirmation time to obtain this time point The number of &quot;unread&quot; messages and &quot;unread&quot; messages after that. <br>Therefore, the <code>unread message</code> and <code>unread message number</code> obtained by different terminals may be inconsistent</td><td><code>unread message</code> still takes the terminal as the dimension, but <code>unread message number</code> takes the user as the dimension . If message A is &quot;read&quot; on the desktop side, the mobile phone side can still consider it &quot;unread&quot;, but the number of unread messages pushed to all clients of the user is uniformly reduced by 1<br>So the different ends get <code>Unread Messages</code> may be inconsistent, but <code>Unread Message Count</code> is consistent</td></tr><tr><td>Supplement</td><td>As mentioned above, this solution can actually &quot;forcibly&quot; support the number of unread messages when pushing offline messages. <br>But because this solution is not designed for frequently reading the number of unread messages, if the server calculates the number of unread messages in real time every time a message is pushed, its performance is obviously not advisable. Therefore, it is not supported in practice</td><td>The above solutions have their own advantages and disadvantages, and which solution to use depends on the business requirements of the specific application. If you do not need to support offline message push and carry the number of unread messages, use the solution on the left, and if you need to support it, use the solution on the right. <br>If the customer has additional requirements on the basis of these two solutions, they need to do secondary development by themselves<br>TODO: This implementation will be supported in the near future</td></tr></tbody></table><h4 id="implementation" tabindex="-1">Implementation <a class="header-anchor" href="#implementation" aria-label="Permalink to &quot;Implementation&quot;">​</a></h4><p>TODO</p><h3 id="about-the-implementation-of-offline-push" tabindex="-1">About the implementation of offline push <a class="header-anchor" href="#about-the-implementation-of-offline-push" aria-label="Permalink to &quot;About the implementation of offline push&quot;">​</a></h3><p>For online users, developers can use the notification attribute to configure whether to allow the server to actively push messages to online users (the default is true). For offline users, the implementation of offline push usually needs to use the push SDK provided by the mobile phone operator to perform offline push through its channel.</p><p>However, since Turms itself does not connect to any operator and does not plan to connect, you need to implement custom offline push logic through the <code>NotificationHandler</code> plug-in. The Handler provides a handle function and accepts four parameters: message information, online user ID, offline user ID, and optional number of unread messages. You can use this function to call the push SDK provided by the manufacturer to implement offline push logic .</p><h3 id="message-batch-pull" tabindex="-1">Message batch pull <a class="header-anchor" href="#message-batch-pull" aria-label="Permalink to &quot;Message batch pull&quot;">​</a></h3><p>TODO: Not supported yet. Since message fetching is controlled by the client itself, this feature can be easily implemented efficiently and flexibly, and we will provide support before the official release.</p><h3 id="extra-large-group" tabindex="-1">extra large group <a class="header-anchor" href="#extra-large-group" aria-label="Permalink to &quot;extra large group&quot;">​</a></h3><p>It is not difficult to implement a very large group, but its business requirements and scenarios are very different from those of general social applications, so a set of special strategies is required to support very large groups.</p><p>Strategy (TODO)</p><ol><li>Messages are sent according to priority</li><li>Intelligently limit the peak value of messages, and actively discard messages according to the server status and message priority</li><li>Send messages in buckets (subgroups)</li><li>Message roaming is usually not required</li></ol>`,83),n=[i];function r(l,h,d,c,u,m){return t(),s("div",null,n)}const f=e(o,[["render",r]]);export{g as __pageData,f as default};
