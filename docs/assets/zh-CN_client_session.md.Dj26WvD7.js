import{_ as e,c as t,o as d,a3 as r}from"./chunks/framework.ViWktWD6.js";const m=JSON.parse('{"title":"会话的生命周期","description":"","frontmatter":{},"headers":[],"relativePath":"zh-CN/client/session.md","filePath":"zh-CN/client/session.md"}'),o={name:"zh-CN/client/session.md"},n=r('<h1 id="会话的生命周期" tabindex="-1">会话的生命周期 <a class="header-anchor" href="#会话的生命周期" aria-label="Permalink to &quot;会话的生命周期&quot;">​</a></h1><p>Turms客户端的会话生命周期比较容易理解，具体而言：先通过<code>driver.connect(...)</code>进行网络层的连接，而后通过<code>userService.login(...)</code>进行业务层面上的登录操作，在登录成功后，对应的会话就建立了。最后再通过<code>userService.logout(...)</code>方法向服务端发送会话关闭通知，同时也会关闭网络层连接。</p><p>为了保持逻辑简单，也方便上层开发者自行组合各种逻辑。Turms不提供诸如自动重连、自动路由跳转等操作，一方面开发者可以很容易地实现该类逻辑，另一方面，这类“隐藏”的内部逻辑会使得上层开发者难以把控底层驱动行为，在一些时候反而会成为绊脚石。</p><p>拓展：如同WebSocket基于关闭帧的会话关闭机制，Turms服务端在关闭会话时，也会通过一个会话关闭信令来通知客户端该会话已关闭，并在信令被Flushed后，通知底层WebSocket/TCP关闭连接。Turms服务端不需要等待客户端对会话关闭信令的任何响应，客户端也不会向服务端发送有关会话关闭信令的响应。</p><h2 id="生命周期回调钩子" tabindex="-1">生命周期回调钩子 <a class="header-anchor" href="#生命周期回调钩子" aria-label="Permalink to &quot;生命周期回调钩子&quot;">​</a></h2><table><thead><tr><th>层次</th><th>名称</th><th>调用时机</th><th>提醒</th></tr></thead><tbody><tr><td>网络层</td><td>driver.addOnConnectedListener</td><td>当网络层连接建立时</td><td>通常您并不需要通过<code>addOnConnectedListener</code>来添加连接监听事件，<br>而是在<code>driver.connect(...)</code>异步执行成功后，执行自定义代码</td></tr><tr><td>网络层</td><td>driver.addOnDisconnectedListener</td><td>当网络层连接断开时</td><td></td></tr><tr><td>业务逻辑层</td><td>userService.addOnOnlineListener</td><td>当会话建立，即用户上线时</td><td>通常您并不需要通过<code>addOnOnlineListener</code>来添加上线监听事件，<br>而是在<code>userService.login(...)</code>异步执行成功后，执行自定义代码</td></tr><tr><td>业务逻辑层</td><td>userService.addOnOfflineListener</td><td>当会话断开，即用户下线时</td><td></td></tr></tbody></table>',6),c=[n];function a(s,i,h,l,_,u){return d(),t("div",null,c)}const b=e(o,[["render",a]]);export{m as __pageData,b as default};
