import{_ as o,c as e,o as t,V as c}from"./chunks/framework.fogKwqBf.js";const P=JSON.parse('{"title":"与服务端通信时使用的数据格式","description":"","frontmatter":{},"headers":[],"relativePath":"zh-CN/client/communication-protocol.md","filePath":"zh-CN/client/communication-protocol.md"}'),i={name:"zh-CN/client/communication-protocol.md"},a=c('<h1 id="与服务端通信时使用的数据格式" tabindex="-1">与服务端通信时使用的数据格式 <a class="header-anchor" href="#与服务端通信时使用的数据格式" aria-label="Permalink to &quot;与服务端通信时使用的数据格式&quot;">​</a></h1><p>对于一般请求与响应而言：</p><ul><li>基于纯TCP协议实现的客户端：varint编码的正文长度 + 正文（Protobuf编码的<code>TurmsNotification</code>或<code>TurmsRequest</code>）</li><li>基于WebSocket协议实现的客户端：正文（Protobuf编码的<code>TurmsNotification</code>或<code>TurmsRequest</code>）。正文的字节长度信息通过底层的WebSocket Frame传输</li></ul><p>对于心跳请求而言：</p><ul><li>基于纯TCP协议实现的客户端：一个长度为一字节的<code>[0]</code>字节数组。这里的数值<code>0</code>其实是指“该Payload的长度在varint编码下为一字节长度的0”，即Payload为0字节。</li><li>基于WebSocket协议实现的客户端：一个正文为空（0字节）的Binary类型消息</li></ul><p>补充：Turms不通过WebSocket的PING/PONG来实现心跳的原因是：</p><ul><li>各浏览器WebSocket实现的PING消息发送时间间隔不同</li><li>上层代码无法控制PING/PONG的行为，甚至无法感知行为的发生</li><li>网络层面的心跳逻辑不应该和应用层的心跳耦合</li></ul>',7),l=[a];function r(n,d,s,_,u,m){return t(),e("div",null,l)}const h=o(i,[["render",r]]);export{P as __pageData,h as default};
