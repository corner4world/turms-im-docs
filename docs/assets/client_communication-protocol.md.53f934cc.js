import{_ as e,c as t,o,R as a}from"./chunks/framework.b6850781.js";const f=JSON.parse('{"title":"Communication Protocol Used Between Client and Server","description":"","frontmatter":{},"headers":[],"relativePath":"client/communication-protocol.md"}'),i={name:"client/communication-protocol.md"},n=a('<h1 id="communication-protocol-used-between-client-and-server" tabindex="-1">Communication Protocol Used Between Client and Server <a class="header-anchor" href="#communication-protocol-used-between-client-and-server" aria-label="Permalink to &quot;Communication Protocol Used Between Client and Server&quot;">​</a></h1><h2 id="data-format" tabindex="-1">Data Format <a class="header-anchor" href="#data-format" aria-label="Permalink to &quot;Data Format&quot;">​</a></h2><p>For general requests and responses:</p><ul><li>Client based on the pure TCP protocol: varint-encoded payload length + payload (Protobuf-encoded <code>TurmsNotification</code> or <code>TurmsRequest</code>).</li><li>Client based on the WebSocket protocol: payload (Protobuf-encoded <code>TurmsNotification</code> or <code>TurmsRequest</code>). The byte length of the payload is transmitted through the underlying WebSocket frame.</li></ul><p>For heartbeat requests:</p><ul><li>Client based on the pure TCP protocol: a byte array <code>[0]</code> with the length of one byte. The value <code>0</code> here actually means &quot;the length of the payload is 0 with a length of one byte under varint encoding&quot;, that is, the payload is 0 bytes.</li><li>Client based on the WebSocket protocol: a binary message with an empty body (0 bytes).</li></ul><p>Supplement: The reasons why Turms does not implement heartbeat through WebSocket&#39;s PING/PONG are:</p><ul><li>The time interval for sending PING frames implemented by each browser&#39;s WebSocket is different.</li><li>The upper layer code cannot control the behavior of PING/PONG, or even perceive the occurrence of the behavior.</li><li>The heartbeat logic at the network level should not be coupled with the heartbeat at the application layer.</li></ul><h2 id="xmpp" tabindex="-1">XMPP <a class="header-anchor" href="#xmpp" aria-label="Permalink to &quot;XMPP&quot;">​</a></h2><p>XMPP is an open instant messaging protocol based on XML.</p><p>Reasons why Turms itself does not use the XMPP protocol:</p><ol><li>Very inefficient design. Mainly reflected in two aspects: <ol><li>The data format adopts the redundant and inefficient XML protocol, and its metadata is often larger than the actual transmitted data.</li><li>In the design of XMPP, there are a lot of inefficient designs, such as converting the user avatar picture into Base64 text for transmission, or if the user modifies some personal information, the server needs to actively push the information to all the contacts in the contact list.</li></ol></li><li>Poor scalability. Some articles say that XMPP is highly scalable, but this &quot;extensible&quot; is only relative to those protocols that are not scalable. The truly scalable protocol must be a self-developed protocol.</li></ol><p>However, considering the following points, the Turms server plans to support the XMPP protocol in the future:</p><ol><li>Most of the well-known XMPP open source server projects have old-fashioned technical architectures, outdated technology stacks, and poor performance. Although some open source XMPP servers will advertise their &quot;Scalable&quot; architecture, its scalability pales in comparison to Turms. In the true sense, Turms is a project that strives to achieve the ultimate in all aspects (including scalability) in terms of architecture, code implementation, database design, etc. Therefore, Turms can overwhelmingly defeat them in the field of medium and large IM.</li><li>Reuse rich XMPP client implementations on the Internet.</li></ol><p>Of course, because XMPP itself has many inefficient designs, Turms will not support these designs in the future.</p>',15),r=[n];function l(s,c,h,d,u,p){return o(),t("div",null,r)}const b=e(i,[["render",l]]);export{f as __pageData,b as default};
