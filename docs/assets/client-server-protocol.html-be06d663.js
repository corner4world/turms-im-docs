import{_ as e,p as l,q as o,a1 as i}from"./framework-7f102627.js";const r={},c=i('<h1 id="与服务端通信时使用的数据格式" tabindex="-1"><a class="header-anchor" href="#与服务端通信时使用的数据格式" aria-hidden="true">#</a> 与服务端通信时使用的数据格式</h1><p>对于一般请求与响应而言：</p><ul><li>基于纯TCP协议实现的客户端：varint编码的正文长度 + 正文（Protobuf编码的<code>TurmsNotification</code>或<code>TurmsRequest</code>）</li><li>基于WebSocket协议实现的客户端：正文（Protobuf编码的<code>TurmsNotification</code>或<code>TurmsRequest</code>）。正文的字节长度信息通过底层的WebSocket Frame传输</li></ul><p>对于心跳请求而言：</p><ul><li>基于纯TCP协议实现的客户端：一个长度为一字节的<code>[0]</code>字节数组。这里的数值<code>0</code>其实是指“该Payload的长度在varint编码下为一字节长度的0”，即Payload为0字节。</li><li>基于WebSocket协议实现的客户端：一个正文为空（0字节）的Binary类型消息</li></ul><p>补充：Turms不通过WebSocket的PING/PONG来实现心跳的原因是：</p><ul><li>各浏览器WebSocket实现的PING消息发送时间间隔不同</li><li>上层代码无法控制PING/PONG的行为，甚至无法感知行为的发生</li><li>网络层面的心跳逻辑不应该和应用层的心跳耦合</li></ul><h2 id="xmpp" tabindex="-1"><a class="header-anchor" href="#xmpp" aria-hidden="true">#</a> XMPP</h2><p>XMPP是一种以XML为基础的开放式即时通信协议。</p><p>Turms自身不采用XMPP协议的原因：</p><ol><li>设计非常低效。主要体现在两个方面： <ol><li>数据格式采用了冗余低效的XML协议，其元数据很多时候比实际传输的数据还大。</li><li>XMPP的流程设计中，存在大量低效设计，比如将用户头像图片转换成Base64文本进行传输，又比如用户修改了某些个人信息，服务端需要将该信息主动推送给其联系列表的所有用户。</li></ol></li><li>拓展性差。一些文章会说XMPP拓展性强，但这种“拓展性强”也只是相对于那些没啥拓展性的协议而言的。真正拓展性强的协议肯定是自研协议。</li></ol><p>但考虑到以下几点，Turms服务端计划未来支持XMPP协议：</p><ol><li>大部分知名的XMPP开源服务端项目的技术架构老套，技术栈陈旧，并且性能都不怎么样。尽管部分开源XMPP服务端会宣传自己的架构可拓展性“Scalable”强，但其可拓展性跟Turms比起来，就相形见绌了。Turms是在真正意义上，在架构、自身代码实现、数据库设计等方面，尽量把各方面（包括可拓展性）做到极致的项目，因此在中大型IM领域，Turms可以对其进行降维打击。</li><li>复用互联网上丰富的XMPP客户端实现。</li></ol><p>当然，由于XMPP自身存在很多低效的流程设计，因此Turms未来也不会支持这些设计。</p>',14),t=[c];function a(s,P){return l(),o("div",null,t)}const u=e(r,[["render",a],["__file","client-server-protocol.html.vue"]]);export{u as default};
