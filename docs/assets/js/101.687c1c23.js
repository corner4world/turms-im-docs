(window.webpackJsonp=window.webpackJsonp||[]).push([[101],{452:function(e,t,r){"use strict";r.r(t);var n=r(25),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("p",[e._v("线程模型")]),e._v(" "),r("p",[e._v("Turms服务端由三大部分组成：1. 对外提供业务服务（包括HTTP与WebSocket）的Netty服务端；2. Turms服务端之间通信的Netty客户端与服务端；3. 与MongoDB服务端进行交互的Netty客户端。")]),e._v(" "),r("p",[e._v("Turms的主要线程模型比较清晰。")]),e._v(" "),r("ol",[r("li",[e._v("对外提供业务服务（包括HTTP与WebSocket）的Netty服务端。一个Accpetor线程？与")]),e._v(" "),r("li")]),e._v(" "),r("p",[r("strong",[e._v("注意：本文是针对Turms自身的使用场景，并以Turms的角度对其中涉及到的线程进行讲解，而非单纯讲解技术框架的知识点。")])]),e._v(" "),r("p",[e._v("Turms集群间交互")]),e._v(" "),r("p",[e._v("Turms集群成员的TCP连接监听：IO.thread-Acceptor")]),e._v(" "),r("p",[e._v("Node->DefaultNodeContext->TcpIpNetworkingService->Networking（NioNetworking）+ioService。")]),e._v(" "),r("p",[e._v("TcpIpAcceptor->AcceptorIOThread")]),e._v(" "),r("p",[e._v("当实例化HazelcastInstanceImpl时，会调用Node实例的start方法，该方法又会调用TcpIpNetworkingService的start方法，该方法又会调用NioNetworking的restart方法+startAcceptor。")]),e._v(" "),r("p",[e._v("startAcceptor会new一个TcpIpAcceptor实例并start，该实例包含一个AcceptorIOThread线程。当TcpIpAcceptor的start被调用后，其下的AcceptorIOThread也会被start并在run实现处开始监听TCP的连接事件。")]),e._v(" "),r("p",[e._v("当一个新TCP连接建立后，新的SocketChannel会TcpIpEndpointManager.newChannel中的networking.register绑定pipeline，（并且出入站pipeline各由一个NioThread负责），并包装成NioChannel，并交由TcpIpEndpointManager进行统一管理（acceptedChannels）。")]),e._v(" "),r("p",[e._v("NioNetworking是负责网络I/O操作的核心类，它管理着三个重要对象：")]),e._v(" "),r("p",[e._v("NioThread类型的inputThreads（IO.thread-in-），负责处理inbound数据。")]),e._v(" "),r("p",[e._v("NioThread类型的outputThreads（IO.thread-out-），负责处理outbound数据。")]),e._v(" "),r("p",[e._v("Set<"),r("NioChannel",[e._v(" channels，负责存储当前Turms服务端实例与其他Turms服务端实例的NioChannel。该类包含着inboundPipeline（其中又包含着上述提到的某一个inputThreads实例）")])],1),e._v(" "),r("div",{staticClass:"language-? extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("TcpIpEndpointManager?\n")])])]),r("p",[e._v("传输")]),e._v(" "),r("p",[e._v("TcpIpEndpointManager.transmit->TcpIpConnection.write->NioChannel.write->NioOutboundPipeline.write -> executePipeline->flushToSocket")]),e._v(" "),r("p",[e._v("RPC：")]),e._v(" "),r("p",[e._v("生成与发送请求")]),e._v(" "),r("p",[e._v("Request在如Spring的scheduler线程触发，由SerializationService进行序列化，被封装为MemberCallableTaskOperation（serviceName为“hz:impl:executorService”），并由com.hazelcast.spi.impl.operationservice.impl.OperationServiceImpl#invokeOnTarget触发传输逻辑，如果是远程Member")]),e._v(" "),r("p",[e._v("com.hazelcast.spi.impl.operationservice.impl.Invocation#doInvokeRemote")]),e._v(" "),r("p",[e._v("接受请求")]),e._v(" "),r("p",[e._v("RPC接受方接收到Packet对象，则会通过com.hazelcast.internal.serialization.SerializationService#toObject生成对应的Operation对象，将Packet或者Operation对象（具体参考com.hazelcast.spi.impl.operationexecutor.impl.OperationThread#process，该Thread会将Packet交由com.hazelcast.spi.impl.operationservice.impl.OperationRunnerImpl#run(com.hazelcast.internal.nio.Packet)进行执行，并再传递给DistributedExecutorService，它会execute方法中将Operation与Runnable或Callable对象封装成Processor，并存储到submittedTasks变量中，并调用executionService.excute执行，当执行完成后会移除对应的submittedTasks内的实例")]),e._v(" "),r("p",[e._v("发送响应")]),e._v(" "),r("p",[e._v("com.hazelcast.executor.impl.DistributedExecutorService.Processor#run")]),e._v(" "),r("p",[e._v("DistributedExecutorService.Processor#sendResponse")]),e._v(" "),r("p",[e._v("OutboundResponseHandler#sendResponse，若是正常返回结果，则触发OutboundResponseHandler#sendNormalResponse，它会再触发OutboundResponseHandler#toNormalResponsePacket生成packet并调用OutboundResponseHandler#transmit，其会触发TcpIpConnection#write进行输出")]),e._v(" "),r("p",[e._v("RPC的response至少由Cached Thread（由operationexecutor管理的OperationThread，其管理着一个OperationQueueImpl），")])])}),[],!1,null,null,null);t.default=o.exports}}]);