(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{433:function(v,_,t){"use strict";t.r(_);var r=t(24),e=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"通信协议与格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通信协议与格式"}},[v._v("#")]),v._v(" 通信协议与格式")]),v._v(" "),t("h2",{attrs:{id:"接入层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接入层"}},[v._v("#")]),v._v(" 接入层")]),v._v(" "),t("p",[v._v("Turms的接入层通信协议与传输格式采用现代优秀商业即时通讯方案的主流实现，即：")]),v._v(" "),t("ol",[t("li",[v._v("JVM平台（如Android与桌面端）：TCP（+TLS）与UDP（TODO）混合 -> 自定义应用层协议（通常是1~5字节的变长包头） + 数据Payload（Protobuf）")]),v._v(" "),t("li",[v._v("Swift支持的平台（如）")])]),v._v(" "),t("p",[v._v("Turms的网络层协议设计与大部分现代商业即时通讯方案的设计几乎一样， 即：")]),v._v(" "),t("p",[v._v("业务数据传输：TCP（+SSL）-> WebSocket + 数据Payload（Protobuf）")]),v._v(" "),t("p",[v._v("部分信令（TODO）：UDP + 数据Payload（自定义二进制格式）")]),v._v(" "),t("p",[v._v("额外补充：Turms允许客户端调用messageService.sendMessage来传输二进制数据，但切忌不要用它来大的二进制数据。因为一个Turms客户端内的所有请求公用一个TCP通道，因此传输大的二进制数据会导致其他请求阻塞。")]),v._v(" "),t("p",[v._v("对于Turms而言，")]),v._v(" "),t("p",[v._v("但总的而言，方案“WebSocket+Protobuf”带来的额外开销，以及远小于传统方案“TCP+JSON”带来的额外开销。")]),v._v(" "),t("h3",{attrs:{id:"通信协议"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#通信协议"}},[v._v("#")]),v._v(" 通信协议")]),v._v(" "),t("p",[v._v("下述内容是在实际工程领域（而非纯理论学术领域），针对消息传输与通知推送场景（不涉及音视频通话领域）而进行的简要总结。")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("传输协议")]),v._v(" "),t("th",[v._v("优点")]),v._v(" "),t("th",[v._v("缺点")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("基于TCP")]),v._v(" "),t("td",[v._v("1. 通俗易懂，基础功能易于实现"),t("br"),v._v("2.")]),v._v(" "),t("td",[v._v("1. 客户端SSL加密层的跨平台实现复杂，需要做大量的适配工作（尤其Android平台），同时又几乎没有纯粹基于TCP+SSL提供的跨平台客户端框架"),t("br"),v._v("2. 协议")])]),v._v(" "),t("tr",[t("td",[v._v("基于UDP")]),v._v(" "),t("td",[v._v("1. 通俗易懂，基础功能易于实现"),t("br"),v._v("2. 协议精简，适合高并发场景"),t("br"),v._v("3. 无传输确认机制，适合弱网环境")]),v._v(" "),t("td",[v._v("1. 安全性差，客户端不支持（Android）或高版本（iOS）DTLS方案"),t("br"),v._v("2. 增加了被UDP Flood攻击的可能性"),t("br"),v._v("3. 稳定性差")])]),v._v(" "),t("tr",[t("td",[v._v("基于WebSocket")]),v._v(" "),t("td",[v._v("1. 客户端生态齐全且相对成熟，客户端框架都默认集成了SSL加密层")]),v._v(" "),t("td",[v._v("1. 客户端需要传输冗余的Mask数据（2~4字节，通常4字节）"),t("br"),v._v("2. 对于传输数据，客户端需要进行冗余的全量Mask操作，服务端也需要进行全量Unmask操作，增加冗余内存与CPU开销"),t("br")])]),v._v(" "),t("tr",[t("td"),v._v(" "),t("td"),v._v(" "),t("td")]),v._v(" "),t("tr",[t("td"),v._v(" "),t("td"),v._v(" "),t("td")])])]),v._v(" "),t("p",[v._v("补充：")]),v._v(" "),t("ul",[t("li",[v._v("WebSocket协议设计考虑到了HTTP代理服务器的安全问题，而引入了Masking机制，但对于Turms而言，这是完全不必要的。因此会带来上述的冗余问题")]),v._v(" "),t("li")]),v._v(" "),t("p",[v._v("首先说通信协议，Turms牺牲采用Protobuf。")]),v._v(" "),t("p",[v._v("除了握手的HTTP请求，WebSocket的overhead为。")]),v._v(" "),t("p",[v._v("Turms之后还将基于弱网环境使用UDP（根据XX，自动切换使用WebSocket或者可靠UDP）")]),v._v(" "),t("h3",{attrs:{id:"传输格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#传输格式"}},[v._v("#")]),v._v(" 传输格式")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("传输格式")]),v._v(" "),t("th",[v._v("优点")]),v._v(" "),t("th",[v._v("缺点")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("XMPP")]),v._v(" "),t("td",[v._v("提供即时通讯协议标准，以实现多厂商间的产品能够互联通信")]),v._v(" "),t("td",[v._v("1. 正是因为其标准化，导致其灵活性差，真正适合的领域只有小规模的企业内部通讯（如同许多通用的前端UI模板）"),t("br"),v._v("2. 基于XML设计，格式极为冗余")])]),v._v(" "),t("tr",[t("td",[v._v("JSON")]),v._v(" "),t("td",[v._v("通俗易懂，使用方便")]),v._v(" "),t("td",[v._v("基于人类可读编码，格式冗余")])]),v._v(" "),t("tr",[t("td",[v._v("XML")]),v._v(" "),t("td",[v._v("人类可读")]),v._v(" "),t("td",[v._v("基于人类可读编码，格式极为冗余")])]),v._v(" "),t("tr",[t("td",[v._v("Protobuf")]),v._v(" "),t("td",[v._v("1. 编码效率较高")]),v._v(" "),t("td",[v._v("1. 拓展性差，"),t("br")])]),v._v(" "),t("tr",[t("td",[v._v("自定义二进制格式")]),v._v(" "),t("td",[v._v("1. 按Bit定制化通讯格式，效率极高（比Protobuf高得多）")]),v._v(" "),t("td",[v._v("1. 拓展性极差。通常和Protobuf搭配使用"),t("br"),v._v("2. 要求企业需求稳定，且格式设计师的设计功底扎实")])])])]),v._v(" "),t("p",[v._v("还有其他一些类Protobuf的二进制编码格式，诸如追求内存利用率的flatbuffers，以及其他小众甚至被淘汰的二进制格式，但Protobuf其实已成为二进制格式编码的事实标准，且该类因此")]),v._v(" "),t("p",[v._v("从底层往上层看，传输层采用TCP的。早期一些即时通讯应用采用UDP的原因是：当时没有epoll这种可以支持成千上万tcp并发连接的技术,所以他们使用了udp,然后在udp上面封装了一下,模拟了一下tcp,解决了大并发的问题,之后因为做的很nb了,虽然epoll这种技术出现了,还是没有改回使用tcp了.现在再做类似的东西就不需要使用udp了.")]),v._v(" "),t("p",[v._v("背景")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("早期网络环境差，UDP的带宽利用比TCP更高。接入带宽很窄而且抖动特别厉害（例如延时突发性地暴增、路由层面的变化导致路由黑洞）。")]),v._v(" "),t("p",[v._v("TCP因为拥塞控制、保证有序等原因，在这种网络状态上对带宽的利用是非常低的。而且因为网络抖动的原因，应用层心跳超时（一般不依靠keepalive）应用层主动断掉socket之后TCP需要三次握手才能重新建立链接，一旦出现频繁的小抖动就会使得带宽利用更低。而等待四次挥手的时间，也会占用服务器上宝贵的资源。")]),v._v(" "),t("p",[v._v("UDP在这种情况下的表现。使用UDP对抗网络抖动，说到底就是在应用层比TCP更快地探测和重传，一旦超过一定的时间没有收到回复，客户端可以选择马上重试或者换一个IP：PORT重试（假如你的服务像QQ一样有多个接入），在服务器端则可以果断地断掉socket。而可以应用UDP的时候，往往是你的应用层协议本身已经具备了一定的面向连接的特性。如果你应用层的协议已经达到了一定程度的消息幂等，客户端可以几乎无脑地进行重传，这样就可以尽可能地降低网络抖动的影响，同时也可以尽可能地利用整个带宽。而刚好QQ的协议，就具备类似的特点。")]),v._v(" "),t("p",[v._v("简单来说就是我们可以使用UDP实现一个面向连接协议，这个协议可以很好地适应当时的网络状况和QQ本身的业务。但凡事都有成本，成本就是你的应用层协议本身需要去实现抵抗网络异常带来的问题。例如乱序、例如业务数据的分片和重组、例如网络状态探测等等等等")]),v._v(" "),t("p",[v._v("而现在UDP也应用在很多跨运营商、跨地域、跨机房之间的服务调用当中。原因无它，就是网络烂到一定程度了。")])]),v._v(" "),t("li",[t("p",[v._v("因为当时没有epoll这种可以支持成千上万tcp并发连接的技术,所以他们使用了udp,然后在udp上面封装了一下,模拟了一下tcp,解决了大并发的问题,之后因为做的很nb了,虽然epoll这种技术出现了,还是没有改回使用tcp了.现在再做类似的东西就不需要使用udp了.")])])]),v._v(" "),t("p",[v._v("到了移动互联网时代，鉴于移动网络的不可靠性等特点，再加上手机的省电策略、流量压缩等")]),v._v(" "),t("h2",{attrs:{id:"rpc层"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#rpc层"}},[v._v("#")]),v._v(" RPC层")]),v._v(" "),t("p",[v._v("由于各主流RPC框架要么实现低效，要么为异构微服务架构而引入对Turms冗余的设计（如gRPC），因此Turms各服务间的通信协议与通信格式都是自研实现的。具体而言：")]),v._v(" "),t("p",[v._v("通信协议：“TCP(+SSL)+RSocket”（RSocket在网络协议层为Turms提供背压和流量控制，以取代传统的Kafka消息队列方案）")]),v._v(" "),t("p",[v._v("通信格式是自定义的二进制编码+Protobuf。")]),v._v(" "),t("p",[v._v("im.turms.server.common.cluster.service.rpc.RpcService")])])}),[],!1,null,null,null);_.default=e.exports}}]);