import{_ as e,o as t,c as o,U as a}from"./chunks/framework.95a60cb2.js";const f=JSON.parse('{"title":"Basic Development Rules","description":"","frontmatter":{},"headers":[],"relativePath":"server/development/rules.md","filePath":"server/development/rules.md"}'),n={name:"server/development/rules.md"},s=a(`<h1 id="basic-development-rules" tabindex="-1">Basic Development Rules <a class="header-anchor" href="#basic-development-rules" aria-label="Permalink to &quot;Basic Development Rules&quot;">​</a></h1><h2 id="conservative-design-vs-radical-design" tabindex="-1">Conservative Design vs. Radical Design <a class="header-anchor" href="#conservative-design-vs-radical-design" aria-label="Permalink to &quot;Conservative Design vs. Radical Design&quot;">​</a></h2><p>Java itself is a very conservative language, and its ecology is also very conservative. Its design principle is to &quot;provide a set of safe APIs, and how Java users use these APIs will not cause Java internal errors&quot; (except for Unsafe classes), so various access control mechanisms, internal memory copies and repeated locking are provided. The code writing principle of the Turms server is generally &quot;How to run the program fast, how to write. As long as the Caller dares to pass or use data indiscriminately, we will report an error or ignore it directly.&quot; For example, <code>StringUtil</code> of Turms uses <code>jdk.internal.misc.Unsafe#getReference</code> to obtain the <code>byte[]</code> object inside the <code>String</code> object to avoid memory copying, and the Caller needs to ensure that it does not &quot;do anything wrong&quot;. The <code>String#getBytes()</code> provided by Java itself is to ensure that the user cannot modify the internal <code>byte[]</code>, so the <code>byte[]</code> object is copied and passed to the Caller.</p><p>Therefore, in the practice of strings, for a conventional Spring-based Web application, after an HTTP request is cut from the TCP byte stream, it may need to be repeated in <code>String</code>, <code>StringBuilder</code>, <code>byte[]</code>, <code> HeapByteBuffer</code>, <code>DirectByteBuffer</code> and other data are switched and spliced. Finally, it is very common for a String type object on the business level to be copied 5 to 30 times by third-party libraries and Java internally.</p><p>Taking a specific application as an example, if we use Spring to create a Controller Bean, and define an API function with a return value type of <code>String</code> in it, so as to return the measurement data in Prometheus format through this API. If we do the &quot;most elegant&quot; writing method under this premise, we need to make at least 4 memory copies of this memory object (excluding the part where the system kernel brushes data to the network card; Turms is optimized and only needs to do one memory copy: that is, the heap Memory to off-heap memory; the actual size of this measurement data is about 8K):</p><ol><li>Write the basic data of Java into <code>StringBuilder</code>, at this time heap memory -&gt; heap memory copy</li><li>StringBuilder#toString(), another heap memory copy</li><li>String#getBytes(), at least another heap memory copy</li><li>Write byte[] to the off-heap memory DirectByteBuffer to hand over to the system kernel for writing data operations</li></ol><p>The effective memory usage rate is extremely low, and note that the above is only the simplest API String response function, and the process involved in the actual application is more complicated, so it is very common for a string to be copied 5 to 30 times after a process things. Therefore, we often see that when an HTTP server is built based on the mainstream ecology of its language, the memory used by a conventional Java Web application may be tens or even hundreds of times that of its equivalent C++ HTTP server.</p><p>In addition to various network APIs, log implementations also need to deal frequently with <code>String</code>. In terms of memory, Turms is much more efficient than general-purpose implementations. Turms directly allocates cached off-heap memory through <code>PooledByteBufAllocator.DEFAULT</code>, and directly writes Java basic data into off-heap memory blocks. And throughout the process, we avoid using Java&#39;s own inefficient implementation, thereby avoiding meaningless heap-to-heap memory copies.</p><p>In summary, although Java itself is relatively conservative, Turms is relatively radical, and prioritizes performance rather than &quot;elegant code&quot;, and makes good use of Unsafe classes when necessary. Of course, our &quot;radical&quot; is also limited, such as: 1. Never replace the Java internal class implementation; 2. Try not to write JNI and C language code</p><p>Replenish:</p><ol><li>For the practice of Java syntax sugar level, our attitude is &quot;relatively indifferent&quot;, such as <code>for (X x : Collection&lt;X&gt;)</code> (need to create an iterator object, consume at least dozens of B) and more efficient <code>for (int i = 0; i &lt; length; i++)</code>, both are allowed</li><li>In addition to the conservative tendency, there is also a very paradoxical phenomenon in the Java circle, that is, &quot;selective neglect during optimization&quot;. A <code>String</code> is copied dozens of times. On the other hand, study JVM memory optimization on a budget. Turms faces various optimization items, mainly based on &quot;cost-effectiveness&quot;, prioritizing the parts with high cost-effectiveness, so as to avoid trying to find fish.</li></ol><h2 id="basic-protocol-for-server-side-development" tabindex="-1">Basic protocol for server-side development <a class="header-anchor" href="#basic-protocol-for-server-side-development" aria-label="Permalink to &quot;Basic protocol for server-side development&quot;">​</a></h2><h3 id="prioritization-of-coding-strategies" tabindex="-1">Prioritization of coding strategies <a class="header-anchor" href="#prioritization-of-coding-strategies" aria-label="Permalink to &quot;Prioritization of coding strategies&quot;">​</a></h3><p>General rules: performance (low time and space complexity) &gt; code readability &gt; design patterns</p><ul><li>Performance &gt; Code readability. For example, use <code>long</code> instead of <code>java.util.Date</code> or <code>java.time.Instant</code> to represent time to avoid creating new objects and calculations during time conversion; another example is <code>im.turms.server.common. The </code>nextIncreasingId<code>function and</code>nextLargeGapId<code> function under the infra.cluster.service.idgen.SnowflakeIdGenerator</code> class repeat about 10 lines of code, but we do not extract this common code to avoid opening up a new method stack (regardless of JVM lag Inline operation).</li><li>Performance &gt; Design Mode. Such as the scene: <ul><li>Iterate over the <code>char[]</code> elements in <code>String</code>. If you use the chain of responsibility mode, you need to use different Handler classes to implement different types of processing logic. Although this can make the logic clear, each Handler needs to traverse <code>char[]</code>, so the time complexity of processing It is <code>O(n*m)</code> (n is the length of char[], and m is the number of Handlers). Codes of this complexity are prohibited in the Turms server code. At this time, it is necessary to write the code in an anti-design mode, write the processing logic in one traversal as much as possible, and try not to open a new function to distinguish logic (this is optional), but use comments to divide different processing logic to avoid function stack overhead.</li><li>The efficient design of the Protobuf model has always been praised, but the code implementation of the official Java version of Protobuf is conservative and inefficient. For example, the Protobuf model is Immutable, and only its Builder is Mutable. Therefore, if you want to modify the Protobuf model, you must first <code>toBuilder()</code> into a Builder, and then recreate a new Protobuf model instance. The effective memory usage rate is low (additional supplement : Its string decoding implementation is also very inefficient. For example, in order to be compatible with lower versions of Java, it uses <code>char[]</code> for encoding, but the String of the new version of Java only stores <code>byte[]</code> inside, so an additional type conversion). And our controllable code is to use the Builder without the Builder to avoid meaningless memory consumption.</li></ul></li></ul><p>Exception: As in rare cases, code readability takes precedence over performance. Take the &quot;Prohibition of using reflection during the processing of client requests and admin API requests&quot; mentioned in the article as an example. Despite this rule, if the request needs to create an Entity object for use by the database driver, then we will still create and populate this object through reflection. Because if you don&#39;t use reflection, you need to write hundreds of field serialization and deserialization logics by hand, which is a huge workload and error-prone. The profitability of using reflection is very high, so reflection is allowed.</p><p>There are many more examples of the above, see the Turms server code for details. When adding new code, just make sure that there is hardly any room for time or space optimization in the newly added code. If there is still room for optimization, but the benefits are low and the implementation is complex, allow for later optimization.</p><h4 id="threads-and-locks" tabindex="-1">Threads and locks <a class="header-anchor" href="#threads-and-locks" aria-label="Permalink to &quot;Threads and locks&quot;">​</a></h4><ul><li><p>The use of elastic thread pools is prohibited, creating new threads requires a dedicated code review</p></li><li><p>Try not to use synchronized and Lock operations (including reentrant locks) during the processing of client requests and admin API requests. If a critical section is really needed, priority should be given to refactoring the code flow or replacing it with CAS technology.</p></li></ul><h4 id="memory-and-gc" tabindex="-1">Memory and GC <a class="header-anchor" href="#memory-and-gc" aria-label="Permalink to &quot;Memory and GC&quot;">​</a></h4><ul><li><p>Prohibit copying of ByteBuf</p></li><li><p>For network I/O operations, the use of non-pooled or heap memory is prohibited, only pooled direct memory is allowed</p></li><li><p>Try not to create new objects, try to use the object pool. As is common in design: In order to logically separate the data models of different layers, the DTO and BO models are specially disassembled. For this scenario, Turms will try to use a data model and implement a response that conforms to the DTO model by customizing Jackson&#39;s serialization logic</p><p>Also: this rule will change after Project Valhalla is released, in particular we will be removing most of the existing object pools</p></li><li><p>Try not to create objects with multiple unused fields. For example, Turms reconstructed MongoDB&#39;s <code>FindOptions</code> model with a custom <code>QueryOptions</code> model. One of the reasons is that the <code>FindOptions</code> model is frequently used, but it has dozens of useless fields.</p></li><li><p>During the processing of client requests and admin API requests, the use of Stream is prohibited</p></li><li><p>Regarding the question of &quot;why some functions that seem to be able to use primitive parameters still use wrapper classes&quot;. Wrapper classes are still used because: although some parameters in a function may seem to be able to use primitives, in fact, these primitives will eventually be passed to Java collection class implementations with a high probability (such as <code>Map&lt;Long, Object&gt;</code>). Functions that accept objects (such as <code>Object</code> types, <code>Long</code> types, generics, etc.) or Object fields as classes, etc. Therefore, if a function just uses primitives on its own, after the entire logic is processed, this primitive is likely to be repeatedly converted between the wrapper class and the primitive many times. To sum up, in most cases, the Turms server uniformly uses wrapper classes to avoid such multiple conversions. Only when we can guarantee that the primitive will not be converted into a wrapper class, we will use the primitive uniformly.</p><p>In addition, this is why we are in <a href="https://turms-im.github.io/docs/server/module/system-resource-management#%E5%85%B3%E4%BA%8Evalhalla%E9%A1%B9%E7%9B%AE" target="_blank" rel="noreferrer">About the Valhalla project</a> said that the design concept of &quot;everything is an object&quot; &quot;lingers like a curse&quot;. It is difficult for a primitive not to be converted into a package in complex logic. Classes, meaningless objects waste a lot of memory, which is why we&#39;ve been waiting for the Valhalla project to finalize wrapper classes and support features like the <code>List&lt;int&gt;</code> type.</p></li></ul><h4 id="proxy-and-reflection" tabindex="-1">Proxy and Reflection <a class="header-anchor" href="#proxy-and-reflection" aria-label="Permalink to &quot;Proxy and Reflection&quot;">​</a></h4><ul><li><p>Do not use dynamic proxy technology (such as Java dynamic proxy, CGLib, Spring AOP, etc.), try not to use proxy or use static compilation technology instead (such as Lombok).</p><p>The only exception: In the plug-in mechanism of the Turms server, Java&#39;s dynamic proxy is used to proxy plug-ins written in JavaScript.</p></li><li><p>During the processing of client requests and admin API requests, unless you need to write a lot of complicated code without using reflection, the use of reflection technology is prohibited in other scenarios. For example: Turms uses reflection when serializing and deserializing hundreds of fields of MongoDB&#39;s Entity model.</p></li></ul><p>In addition, if there is a third-party dependency that violates the above principles, the third-party dependency will be refactored according to the cost-effectiveness schedule.</p><h3 id="text-format" tabindex="-1">text format <a class="header-anchor" href="#text-format" aria-label="Permalink to &quot;text format&quot;">​</a></h3><h4 id="tostring-text-format" tabindex="-1">toString() text format <a class="header-anchor" href="#tostring-text-format" aria-label="Permalink to &quot;toString() text format&quot;">​</a></h4><p>The text format implemented by the Java project <code>toString()</code> is varied, and even the internal code of Java itself has many text formats with inconsistent styles. As far as the bracket style is concerned, there are not only the default <code>[key=value]</code> format of Java record, but also the <code>(key=value)</code> format generated by Lombok, and the <code>{key=value}</code> format generated by Google AutoValue.</p><p>In order to achieve a unified text format, the Turms server project uniformly adopts the following format:</p><ul><li><p>For the prefix and suffix of the text, use <code>{</code> and <code>}</code> respectively, instead of <code>[]</code> or <code>()</code>. Because in the text format design of Turms, <code>[]</code> refers to an array, and <code>()</code> refers to a special mark to make important information more eye-catching. For specific rules, see <code>Server operation log and exception text format</code> below.</p></li><li><p>Use the mainstream <code>=</code> instead of <code>:</code> between keys and values.</p></li><li><p>For string values, you need to use <code>&quot;&quot;</code> to wrap the value; for other non-array values, use the <code>toString()</code> form of the value; for array values, use <code>[]</code> to include the value in the array .</p><p>For example: <code>ClassName{key1=value, key2=[value1, value2]}</code></p></li></ul><p>**Note: The Turms server has not yet unified the text format of <code>toString()</code>, but the content described above is the direction of improvement in the future. **</p><h4 id="server-running-log-and-exception-text-format" tabindex="-1">Server running log and exception text format <a class="header-anchor" href="#server-running-log-and-exception-text-format" aria-label="Permalink to &quot;Server running log and exception text format&quot;">​</a></h4><p>Because there are many details in the text format design of logs and exceptions, and the principles of many common practices are in conflict with each other, and there is no unified best practice in the Java field, almost all large and medium-sized open source projects (including Java itself) source code) cannot achieve a unified text format, but a mix of various text formats, and the specific format depends mainly on the current &quot;feeling&quot; of the engineer.</p><p>Therefore, this section specifically explains which text formats the Turms server uses, and why some other common text formats are not used, so as to reduce readers&#39; confusion in practice.</p><h5 id="the-importance-of-a-uniform-format" tabindex="-1">The Importance of a Uniform Format <a class="header-anchor" href="#the-importance-of-a-uniform-format" aria-label="Permalink to &quot;The Importance of a Uniform Format&quot;">​</a></h5><p>For some text formatting rules, readers may not feel the difference between the rules when reading a single log. But when readers need to read dozens, even hundreds, or thousands of different logs, they can understand how much energy saving in reading using a standardized and unified text format.</p><h5 id="specific-rules" tabindex="-1">specific rules <a class="header-anchor" href="#specific-rules" aria-label="Permalink to &quot;specific rules&quot;">​</a></h5><p>simply put:</p><ul><li>Important information in the text should be put in the end of the sentence as much as possible. Vital information is usually a variable.</li><li>When the important information is at the end of the sentence, you need to use <code>:</code> to separate the important information from other texts. For example: use <code>Could not find the class: my.company.Main</code> instead of <code>The class (my.company.Main) could not be found</code>.</li><li>Sentences do not need to omit the articles <code>a</code>, <code>an</code> and <code>the</code>. This point is especially emphasized because most well-known large and medium-sized open source projects tend to omit articles.</li><li>For noun phrases, restrictive appositions are usually used instead of attributive nouns. For example, restrictive appositions: <code>The collection &quot;messasge&quot;</code> or <code>The setting &quot;turms.whatever.min&quot;</code>; attributive nouns: <code>The &quot;messasge&quot; collection</code> and <code>The &quot;turms.whatever.min&quot; setting</code>.</li><li>Function and use of special symbols:</li></ul><table><thead><tr><th>Role</th><th>Symbols used</th><th>In a sentence</th><th>When paired with <code>: </code></th><th>When paired with an array</th><th>Common examples</th></tr></thead><tbody><tr><td>Represents an array value</td><td><code>[,]</code></td><td>Use <code>[value]</code> format. <br>Such as <code>Detected illegal operations [CREATE, DELETE] on the collection &quot;message&quot;</code></td><td>use <code>: [value]</code> format. <br>Such as <code>Detected illegal operations: [CREATE, DELETE]</code></td><td></td><td></td></tr><tr><td>Indicates interval</td><td><code>[..]</code> closed interval, <code>(..)</code> open interval</td><td>such as: <code>[1..2]</code>, \`\`</td><td></td><td></td><td></td></tr><tr><td>Wrap information that needs to be specially separated for eye-catching</td><td><code>()</code></td><td>Use the <code>(value)</code> format. <br>Such as <code>The path (/turms/1.txt/) is illegal</code></td><td>No need to use <code>()</code>, just use <code>: value</code> format. <br>Such as <code>Could not find any resource from the path: /turms/1.txt</code></td><td>No need to use <code>()</code>, just use <code>[value]</code> format. <br>Such as <code>The paths [/1.txt, /2.txt] are illegal</code></td><td>object, enumeration value, path, domain name, field reference</td></tr><tr><td>Wrap key-value pairs</td><td><code>{}</code></td><td>Use <code>{key=value}</code> format. <br>Example</td><td>use <code>: {key=value}</code> format</td><td>use <code>[{key=value}, {key=value}]</code> format</td><td></td></tr><tr><td>Package name or string value</td><td><code>&quot;&quot;</code></td><td>Use <code>&quot;value&quot;</code> format. <br>Such as <code>The property &quot;turms.whatever.min&quot; must be greater than 0</code>; <code>The setting name &quot;abc123&quot; should not contain any digit</code></td><td>use <code>: &quot;value&quot;</code> format. <br>Such as <code>Unknown property: &quot;turms.whatever.min&quot;</code></td><td>use <code>[&quot;value&quot;, &quot;value&quot;]</code> format. <br>Such as <code>The properties [&quot;turms.whatever.min&quot;, &quot;turms.whatever.max&quot;] are unknown</code></td><td>field name, parameter name, database collection name</td></tr></tbody></table><ul><li><p>Difference between name and reference</p><p>Let’s give a relatively easy-to-understand example first. Take the field name and reference as an example. Suppose there is a field <code>name</code> in a class <code>com.abc.Song</code> (song), then the name of the field is <code>name</code>, When the name is used in a sentence, double quotes <code>&quot;&quot;</code> are required, such as <code>The field &quot;name&quot; contains illegal characters</code>. The reference of the field is <code>com.abc.Song#name</code>, and when the reference is used in a sentence, parentheses <code>()</code> are required, such as <code>The field (com.abc.Song#name) should be accessible</code>.</p><p>But in the actual development process, we will find that many strings themselves can have multiple interpretations. For example, if there is a class whose name is <code>com.my.Main</code>, then this name can be interpreted as either a <code>class name</code> or a <code>class reference</code>. And considering that the class name will not have the serious ambiguity that may be brought about by the above-mentioned <code>name</code>, and the practice of most well-known open source projects of CUHK does not use <code>&quot;&quot;</code> to wrap the class name, so for the class name, when designing Turms, It is uniformly interpreted as a <code>class reference</code> rather than a <code>class name</code>, so this type of reference needs to follow the usage rules of <code>()</code>, not the usage rules of <code>&quot;&quot;</code>.</p></li></ul><p>The next section will explain why Turms is designed this way, and why some other common designs are not used.</p><p><strong>TODO: Update later</strong></p><h2 id="about-the-use-of-dependent-libraries" tabindex="-1">About the use of dependent libraries <a class="header-anchor" href="#about-the-use-of-dependent-libraries" aria-label="Permalink to &quot;About the use of dependent libraries&quot;">​</a></h2><p>Many dependency libraries are keen to abstract and encapsulate the underlying implementation to achieve &quot;internal logic transparency, and users do not need to care about the logic behind it&quot;. Such a design is more practical for some applications that are simple in logic, require fast online, and do not pursue performance. But as a project develops further and further optimized, this uncontrollable abstraction layer will become a stumbling block for troubleshooting, performance optimization, and function customization. Problems caused by the abstraction layer, such as:</p><ul><li><p>Requirement iteration and version update are seriously lagging behind. If our project uses an abstraction layer A dependency, A dependency encapsulates B dependency. If we need to add a new feature or fix a bug to the B dependency, the usual process is: we raise an issue to the B dependency community. If we are lucky, we will get a reply within 2 to 4 days on average. If luck is still good, the other party is willing to change. Assuming that the changes are not significant, the relevant PRs will be merged after 1 week. It may wait 2 weeks, 1 month, or even a few months, and the B dependency finally releases a new version. Then we have to wait for the A dependency to update the B dependency version, which may take another 2 weeks, 1 month, or even a few months. By the time we actually get to use the new features, it may have been a few months. But more often than not, the maintainer of B&#39;s dependency is not willing to modify the relevant code at all.</p></li><li><p>The vast majority of well-known dependent libraries only care about function realization, not performance, and basically have the attitude of &quot;the function can be used, and the performance can make do&quot;. (Turms solves most of the following problems by refactoring dependent code) such as:</p><ul><li><code>mongo-java-driver</code> repeatedly creates a large number of intermediate objects when making API calls. For the default configuration object, no Cache is used.</li><li>Lettuce needs to repeatedly expand the memory when serializing the instruction parameters passed to Redis, and the memory data of the Cache is not cached.</li><li>Log4j2 actually uses <code>getBytes</code> to read the data of the string, and uses <code>StringBuilder</code> to do the splicing of the log (compared to the log implementation of Turms, which directly uses the <code>byte[] value</code> data inside <code>String</code>, and uses the<code> provided by Netty</code> io.netty.buffer.AbstractByteBufAllocator#directBuffer\` to splice logs and do log output). (Supplement: If readers are interested in log implementation, you can read <a href="https://turms-im.github.io/docs/server/module/observability#%E8%87%AA%E7%A0%94%E5%AE%9E%E7%8E%B0-%E6%8B%93%E5%B1%95%E7%9F%A5%E8%AF%86" target="_blank" rel="noreferrer">log implementation</a>, understand how Turms implements logs)</li><li>In the official Java implementation of Protobuf, its string decoding implementation is also very inefficient. For example, in order to be compatible with lower versions of Java, it uses <code>char[]</code> for encoding, but the String of the new version of Java only stores <code>byte[ ]</code>, so a meaningless memory copy is required (note: the string itself is the largest data in the client request).</li><li>Spring is a typical representative of inefficient code, such as: <ul><li>When <code>org.springframework.core.codec.CharSequenceEncoder</code> processes <code>UTF-8</code> encoded strings, 1 character corresponds to 3 bytes to open up DirectByteBuffer for output. In other words, for the above-mentioned 8K Prometheus data, only this piece of Spring needs to use 2.4MB, and an extra 1.6MB is used. Of course, Spring is even more efficient, because it also performs string copying when <code>String#getBytes(...)</code>.</li><li><code>spring-boot-actuator:v2.6.6</code> does not support zero copy when exporting huge heap dump files (see <code>org.springframework.boot.actuate.management.HeapDumpWebEndpoint.TemporaryFileSystemResource#isFile</code>)</li><li>Spring&#39;s AOP is often used to proxy Controller layer method calls, which can be used to capture parsed parameters and print logs (WebFilter cannot obtain parsed parameters). But AOP will add 19 stacks to a method and use a lot of reflection. The time required to call from the AOP proxy to the Controller method layer is even longer than the internal business processing time of Turms (additional supplement: AOP is a very bad design, Spring Should be designed for the chain of responsibility adopted by the Controller layer).</li></ul></li></ul></li></ul><p>To sum up, the code quality of many well-known Java dependent libraries is not high, and even the code performance and quality are worrying, and the source code is shocking to read. Instead, readers can refer to how the Turms server is coded to optimize various details to the extreme.</p><ul><li><p>When the dependency library that focuses on abstract implementation is combined with responsive programming, it will bring developers a hell-level experience in troubleshooting problems, especially when bugs are related to memory that needs to be released manually. In the troubleshooting of conventional problems, we can usually quickly troubleshoot the problem through the stack information. But in reactive programming, such a method usually does not work, and we rely more on logical reasoning to troubleshoot problems. That is, familiarize yourself with the upstream and downstream code (including the code in the dependent package), and deduce all the processes that the code may go through.</p><p>If the code has few abstraction layers and the call relationship is flat, the troubleshooting process is actually very simple. Maybe we only need to glance at dozens of lines of code in a class to roughly know the cause of the problem. However, if a large number of &quot;encapsulation, abstraction, users do not need to pay attention to the underlying implementation logic&quot; dependency libraries are used in the process, the hell-level experience will come. Originally, we might only need a function with dozens of lines to implement all the relevant logic. But if we implement related functions based on the abstract library, when we troubleshoot, the code we may want to check may be A abstract class (A1, A2, A3...) class -&gt; B abstract class (B1, B2, B3.. .)-&gt;C abstract class (C1,C2,C3...)-&gt;..., jump between dozens of classes and dozens of methods, and reason.</p><p>The most typical comparison example is: Turms&#39; <code>im.turms.gateway.access.client.websocket.WebSocketServerFactory#getHttpRequestHandler</code> implements a set of WebSocket handshake logic in a function of dozens of lines. But if this set of logic is implemented by Spring, it will mix the classes under different packages and various logics together. When troubleshooting, if it is accompanied by some memory that needs to be released manually, hell level Here comes the troubleshooting experience. What can be solved with dozens of lines of code, a library like Spring requires thousands of lines of code. For example, there are multiple sets of underlying Web implementations inside WebFlux, which is euphemistically called &quot;encapsulation and abstraction, and users do not need to pay attention to the underlying implementation logic.&quot;</p></li><li><p>Some dependent libraries will automatically suppress exceptions in some places, and the upper-layer application code cannot perceive them. When something goes wrong, the underlying library code and the upper-level application code run on different stacks in most cases. Unless the underlying dependency library supports global exception callbacks, the upper-layer application cannot even perceive the occurrence of exceptions. For some Trivial-level errors, it doesn&#39;t matter if the upper-layer application cannot perceive them. But if it is an abnormality that some upper-layer applications are very concerned about (such as the abnormal disconnection of the RPC TCP connection), this will be the fuse that causes the abnormality and disorder of the entire system.</p></li><li><p>Developers of some well-known dependent libraries even lack the most basic security knowledge. For example, the developers of <code>Log4j</code> actually added code to automatically detect whether there is a <code>\${jndi}</code> pattern in the string to be printed, and if it exists, call the corresponding JNDI service, and enable this function by default. As a developer who specializes in writing log-dependent libraries, he lacks security common sense and has passed PR review.</p></li></ul><p>On the other hand, self-development can avoid all the above-mentioned problems. While improving the controllability of the code, it also greatly reduces the difficulty of research and development and troubleshooting, and improves code performance and resource utilization.</p><p>In summary, when a Turms project references a class library, it usually does not introduce an abstract encapsulation library (such as Spring), but only an implementation library. Points that require performance optimization or logic optimization in the dependent library will be directly refactored inside the Turms project. Considering the difficulty of self-development and code controllability, we will choose self-development as much as possible in most cases.</p><p>Supplement: Although the Java ecosystem is prosperous, there are actually few high-quality libraries. Therefore, most medium and large-scale Java open source projects that pursue performance usually try to develop various functional modules by themselves instead of using third-party dependent libraries, such as: <a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noreferrer">Elasticsearch</a>, <a href="https://github.com/apache/cassandra" target="_blank" rel="noreferrer">Cassandra</a>, <a href="https://github.com/apache/ignite" target="_blank" rel="noreferrer">Ignite</a> . In addition, in the entire Java ecosystem, the only library we currently trust in the technical level of its developers is: Netty</p><h2 id="exception-capture-and-printing" tabindex="-1">Exception capture and printing <a class="header-anchor" href="#exception-capture-and-printing" aria-label="Permalink to &quot;Exception capture and printing&quot;">​</a></h2><p>Role: Understanding the exception capture and printing principles of the Turms server can help developers quickly locate the exception and find the root cause of the exception.</p><p>In reactive programming, the most criticized exception is that exceptions under this programming paradigm are usually very difficult to locate, and their stack information is basically useless. If the developer randomly prints the exception log in the reactive programming mode, it is very likely that the debugger will not even be able to judge where the exception is thrown from the log, let alone reverse the execution code.</p><p>But in fact, the principle and practice of good exception log printing are relatively simple, and if you follow this principle, it usually takes a few seconds or minutes to locate the exception. The basic principle is that the most downstream code throws an exception without printing. If the midstream code needs to translate the exception, it will continue to be thrown upwards after the translation, without printing; the most upstream exception will be received and ** will be printed. As for what code is considered &quot;the most upstream&quot;, the code that calls <code>subscribe()</code> is considered the &quot;most upstream&quot;. This principle is actually very simple in practice, but the exception capture in reactive programming &quot;looks&quot; more complicated. For example, under the <code>im.turms.service.access.servicerequest.dispatcher.ServiceRequestDispatcher#dispatch0</code> function in the turms-service server, there is an operation of &quot;send notifications to relevant users according to the processing results of the Service layer&quot; , whose code is as follows:</p><div class="language-java"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#A6ACCD;"> result</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">name</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">CLIENT_REQUEST_NAME</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">tag</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">CLIENT_REQUEST_TAG_TYPE</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> requestType</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">name</span><span style="color:#89DDFF;">())</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">metrics</span><span style="color:#89DDFF;">()</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">defaultIfEmpty</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">RequestHandlerResultFactory</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">NO_CONTENT</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">doOnEach</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">signal </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(!</span><span style="color:#A6ACCD;">signal</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isOnNext</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#C792EA;">RequestHandlerResult</span><span style="color:#A6ACCD;"> requestResult </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> signal</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">();</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">requestResult </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">null</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">||</span><span style="color:#A6ACCD;"> requestResult</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">code</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">!=</span><span style="color:#A6ACCD;"> ResponseStatusCode</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">OK</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">            </span><span style="color:#82AAFF;">notifyRelatedUsersOfAction</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">requestResult</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> userId</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> deviceType</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">contextWrite</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">signal</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getContextView</span><span style="color:#89DDFF;">())</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">subscribe</span><span style="color:#89DDFF;">(null,</span><span style="color:#A6ACCD;"> t </span><span style="color:#C792EA;">-&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                        </span><span style="color:#89DDFF;font-style:italic;">try</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#C792EA;">TracingCloseableContext</span><span style="color:#A6ACCD;"> ignored </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> context</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">asCloseable</span><span style="color:#89DDFF;">())</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">                            LOGGER</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">error</span><span style="color:#89DDFF;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Failed to notify related users of the action</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> t</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">                        </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">                    </span><span style="color:#89DDFF;">});</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">})</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#89DDFF;">...</span></span></code></pre></div><p>As mentioned above, this piece of code performs the notification delivery operation through the <code>notifyRelatedUsersOfAction</code> function. We don&#39;t care about its internal implementation. We only need to pass <code>subscribe(...)</code> at the most upstream to ensure that it can catch the exceptions that may be thrown. and print it.</p><h3 id="there-are-and-only-custom-exception-classes-inherited-from-runtimeexception" tabindex="-1">There are and only custom exception classes inherited from <code>RuntimeException</code> <a class="header-anchor" href="#there-are-and-only-custom-exception-classes-inherited-from-runtimeexception" aria-label="Permalink to &quot;There are and only custom exception classes inherited from \`RuntimeException\`&quot;">​</a></h3><p>In the Turms server project, there are and only exception classes inherited from <code>RuntimeException</code> can be customized, and exception classes inherited from <code>Exception</code> (<code>Checked Exception</code>) are prohibited from being customized.</p><p>The discussion on whether to use <code>Checked Exception</code> or <code>Unchecked Exception</code> has been divided so far, but now many articles directly criticize <code>Checked Exception</code> as a design failure of Java, and later languages such as Kotlin/Scala/C# don’t even have it at all. The concept of <code>Checked Exception</code>, and now most of the well-known large and medium-sized open source projects generally only customize the subclasses of <code>RuntimeException</code>, but not the subclasses of <code>Checked Exception</code>.</p><p>Common reasons why <code>Checked Exception</code> is bad design include:</p><ul><li><p>As a third-party library/downstream code, <code>Checked Exception</code> has interface signature version compatibility issues.</p></li><li><p>As a large and medium-sized project, when all submodules use <code>Checked Exception</code>, the interface of the upstream code may eventually declare dozens of exceptions. When the exception declaration of the interface is added, deleted, or modified, it will affect the whole body.</p></li><li><p>Inside the Java code, there are exception design conflicts. For example, Lambda in the design of Java Streams does not support throwing <code>Checked Exception</code>. For Lambda in Stream, its implementation must be treated as processing (usually a wrong practice) or converted into <code>Unchecked Exception</code> (losing the use of <code>Checked Exception</code>). Exception<code>meaning), Java even introduced</code>UncheckedIOException\`.</p></li><li><p>In practice, people often avoid the purpose that <code>Checked Exception</code> was designed, so it is better not to use <code>Checked Exception</code>, for example:</p><ul><li>Catch all <code>Exception</code> directly</li><li>Translate <code>Checked Exception</code> to <code>RuntimeException</code>. Such as <code>try { ... } catch (Exception e) { throw new RuntimeException(e); }</code></li><li>Because the stack is too deep, in order to avoid polluting the upstream code, it is possible to directly perform meaningless capture downstream, and it is even possible to directly <code>catch (Exception e) { do nothing }</code> by mistake</li></ul></li><li><p>Many developers will misunderstand exception design, and then mistakenly customize exceptions. For example, many developers think that if it is an exception that can be avoided by the upstream code, use the subclass of RuntimeException. If it is an unavoidable exception in the upstream code, use Checked Exception\`. A similar view is very blindly optimistic and lacks actual project experience and coding experience, because whether the exception thrown downstream can be handled depends on the logic of the upstream code, not The assumptions of the downstream code.</p><p>For example, when the plug-in module of the Turms server loads the plug-in, the class loader of the plug-in may throw <code>NoClassDefFoundError</code>, if according to the early Java team, <code>An Error is a subclass of Throwable that indicates serious problems that a reasonable application should not try to catch</code>, then the upstream code of the plug-in module should not catch <code>Error</code>, but as a server, Turms cannot make the server abnormal because it loads a problematic class plug-in, so the upstream code is really reasonable The approach is to catch these <code>Error</code>, instead of causing the server to crash directly and fall into an abnormal state.</p></li></ul><p>For the Turms server project, considering that the only scenario where <code>Checked Exception</code> can really play a role is: in individual scenarios, when designing downstream functional modules, it is known that the upstream caller code needs to be based on various events thrown downstream. Exceptions are distinguished by exceptions. In order to ensure that the upstream does not miss processing some exceptions thrown by the downstream, you can consider using <code>Checked Exception</code>. But since this kind of scenario is very rare, it is also very bad practice to design downstream code according to the logic of upstream caller code.</p><p>Therefore, in order to avoid various problems caused by <code>Checked Exception</code>, unify the exception design style, and avoid wasting time on &quot;why are they all modules of a certain type, module A uses a certain type of exception, and module B uses a certain type of exception &quot;For such insignificant disputes, in the Turms server project, there are and only exception classes that inherit from <code>RuntimeException</code>, and it is forbidden to customize exception classes that inherit from <code>Exception</code> (<code>Checked Exception</code>).</p>`,63),i=[s];function r(l,c,d,p,h,u){return t(),o("div",null,i)}const y=e(n,[["render",r]]);export{f as __pageData,y as default};
