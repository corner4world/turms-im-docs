import{_ as e,c as l,o,V as i}from"./chunks/framework.fogKwqBf.js";const I=JSON.parse('{"title":"Turms Chat Demo","description":"","frontmatter":{},"headers":[],"relativePath":"zh-CN/client/turms-chat-demo.md","filePath":"zh-CN/client/turms-chat-demo.md"}'),t={name:"zh-CN/client/turms-chat-demo.md"},r=i('<h1 id="turms-chat-demo" tabindex="-1">Turms Chat Demo <a class="header-anchor" href="#turms-chat-demo" aria-label="Permalink to &quot;Turms Chat Demo&quot;">​</a></h1><h2 id="背景" tabindex="-1">背景 <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;背景&quot;">​</a></h2><p>最初，我们是计划先通过让turms-gateway支持XMPP协议来让用户能够自行复用世界上已有的XMPP客户端。但是不管是收费，还是免费的XMPP客户端质量基本都不高，主要体现在：</p><ol><li>大多XMPP客户端项目代码质量差，尤其是很多早期客户端工程师的代码功底很差，甚至会把复杂的UI逻辑与业务逻辑杂糅在一起写（比如著名开源项目JMeter），二次开发不如自己重写。</li><li>不管是商业还是开源的UI设计水平基本都停留在业余爱好者水平。如果一个客户端项目没有专业的UI，我们会对其团队的前端工程师与UI设计师的能力表示怀疑（团队中只要有一位靠谱的、中级水平的前端工程师，就应该有独立设计单一产品UI的能力），也不会推荐用户去用他们的方案。</li><li>几乎没有一个开源的XMPP客户端支持完整的跨平台方案。</li><li>很多质量不高的XMPP客户端甚至需要收费。</li></ol><p>考虑到提供一套跨桌面端与移动端IM应用的开发难度不高，主要是体力活，并且IM应用的UI与功能通用性强（在市面上找10款IM商业应用调研，会发现至少有9款IM的UI与功能是基本类似的），因此决定先提供IM客户端Demo<code>turms-chat-demo-flutter</code>，让Turms的用户能够自己使用或二次开发，之后再支持XMPP协议。</p><h2 id="roadmap" tabindex="-1">RoadMap <a class="header-anchor" href="#roadmap" aria-label="Permalink to &quot;RoadMap&quot;">​</a></h2><ul><li>2023年11月~12月：完成桌面端UI设计；搭建Flutter项目框架；完成桌面端基础组件开发与测试；完整Windows桌面端UI开发与测试。</li><li>2023年12月~2024年1月：完成MacOS桌面端的UI适配工作；完成移动端基础组件开发与测试；完成Android手机端的UI开发与测试。</li><li>2024年1月~2024年2月：完成iOS手机端的UI适配工作。</li><li>2024年2月~3月：完成Web端的UI开发。</li><li>2024年3月~4月：集成turms-client-dart与实现IM业务逻辑（上述任务只有UI开发与测试，不包括业务逻辑）。</li></ul><p>另外：</p><ul><li>考虑到Turms的其他任务、节假日与工作情况，上述时间可能会略有变动。</li><li>无计划支持小程序。</li></ul><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><p>我们想着重提醒项目名中的一词——<code>demo</code>。该词主要有以下几种含义：</p><ol><li>不管是从产品角度，还是技术角度，该客户端<code>demo</code>也只不过是其中<code>可能的</code>的方案之一，用户不应该因为该<code>demo</code>而限制设计自身IM产品的能力，尤其不要认为Turms的服务端是为该<code>demo</code>定制的，正如Turms文档中反复提及Turms是一个通用IM解决方案，致力于解决各种IM场景。</li><li>为用户的二次开发做准备。这主要分为三个方面： <ol><li>UI与业务逻辑分离。方便需要二次开发的团队复用UI来实现自己的业务逻辑，读者甚至可以只用<code>turms-chat-demo-flutter</code>项目，不使用Turms服务端，而是使用自研的IM服务端。</li><li>依旧采用宽松的Apache 2.0，而不是客户端开源项目常见的、更加严格的GPL协议。</li><li>由于全球范围的IM应用的UI设计都非常类似，因此该<code>demo</code>也会实现大部分IM的通用UI与逻辑，一般不提供更为定制化的逻辑，以方面其他团队二次开发。</li></ol></li></ol><p>注意：<code>demo</code>没有<code>质量低</code>的含义，这点读者之后看代码质量与UI设计就可明白。</p><h2 id="关于二次开发" tabindex="-1">关于二次开发 <a class="header-anchor" href="#关于二次开发" aria-label="Permalink to &quot;关于二次开发&quot;">​</a></h2><p>由于Flutter应用的设计模式众多，很多应用缺乏统一的设计，导致一个应用中存在众多互斥的设计，架构看起来非常混乱。</p><p>为了统一本应用的架构与代码设计，方便读者阅读代码，也方便工程师添加代码，本章节对项目的状态管理与架构进行讲解。</p><h3 id="状态管理" tabindex="-1">状态管理 <a class="header-anchor" href="#状态管理" aria-label="Permalink to &quot;状态管理&quot;">​</a></h3><p>Flutter状态管理方案众多，至少有几十种方案。对于应用级的状态管理：turms-chat-demo-flutter采用主流的、Flutter官方推荐的、更符合Flutter自身设计的、更新勤快的方案，即Riverpod。</p><p>尽管Flutter还有其他状态管理方案，但要么是引入不必要的复杂（如：Bloc），要么是侵入性过强（如：GetX），要么是跟Flutter原生风格差异过大，要么是长期不更新，要么是偏实验性的，因此均不采用。</p><p>另外，本应用除了用Riverpod实现状态管理，还顺便用它来实现依赖注入（Dependency Injection）。</p><h3 id="架构" tabindex="-1">架构 <a class="header-anchor" href="#架构" aria-label="Permalink to &quot;架构&quot;">​</a></h3><p>不仅是Flutter的应用架构设计模式本身就很多，而且同一个架构设计也有多种实践方式。本项目基于Flutter应用的设计传统，选择最适合自身情况的架构设计模式：</p><p>对于应用级的架构设计：基于Riverpod，采用MVC+S与MVVM混合架构设计。</p><ul><li>Model =&gt; Repository。负责增删改查外部数据源接口交互的仓储层。</li><li>View =&gt; Widget：负责UI展示。</li><li>Controller + View Model =&gt; Controller：负责接收用户输入，并基于Service执行业务处理逻辑；管理业务组件的业务状态（State），供UI层进行展示。</li><li>Service：负责执行业务处理逻辑，上接Controller，下接Repository。不叫常见的<code>domain</code>是因为<code>domain</code>是一个指代含糊的词，不仅能指代service，也能指代repository，甚至还能同时指代controller、service与repository等，即指代“业务域”。</li></ul><p>提醒：</p><ul><li><p>本章节所述的Controller是应用架构分层中的Controller，而不是Flutter组件的Controller，如AnimationController。</p></li><li><p>有些Flutter项目的Controller不仅仅是Controller，还是（is）View Model。在本应用中，Controller只是Controller，但同时又包含（has）View Model，即状态（State）。</p></li><li><p>复杂的项目可能会采用5层架构，即：View、Controller、Service、Repository、Data Source。但本应用逻辑相对简单，因此只3层与4层架构，即View、Controller、Service（可选）、Repository。</p></li><li><p>如果读者有阅读过有10年以上历史的桌面端开源项目，就经常能发现这类项目的<code>Model</code>类可能会包含比较复杂的业务逻辑。</p><p>这是因为在早期桌面端开发与面向对象设计中，<code>Model</code>是一个更综合的概念，常常同时指代现今更为常见的<code>Model/Entity</code>（数据模型。不包含数据处理逻辑，或者只包含基本的数据处理逻辑）与<code>Repository</code>（获取、处理、响应数据的仓储层）这两个概念。但由于这样的设计明显不符合于关注点分离（Separation of Concerns）的设计理念，因此靠谱的现代项目已经不会采用这样的设计了。</p></li></ul><h3 id="目录结构" tabindex="-1">目录结构 <a class="header-anchor" href="#目录结构" aria-label="Permalink to &quot;目录结构&quot;">​</a></h3><p>基于上述的架构设计，该项目的目录结构大体如下：</p><ul><li><p>ui</p><ul><li>components：共享UI组件（Widgets），如按钮、标签页等。</li><li>screens：应用页面。每个页面除了包括Widgets，还包括各自的Controllers。</li><li>themes：主题。</li></ul></li><li><p>domain</p><ul><li><p>user</p><ul><li>services</li><li>repositories</li></ul></li><li><p>message</p><ul><li>services</li><li>repositories</li></ul></li><li><p>...</p></li></ul></li><li><p>infra：</p><ul><li>preferences：管理应用本地配置。</li><li>routes：路由。</li><li>window：管理桌面端窗口。</li><li>...</li></ul></li></ul>',29),a=[r];function d(c,s,n,p,u,m){return o(),l("div",null,a)}const M=e(t,[["render",d]]);export{I as __pageData,M as default};
